<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D –†–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –ë–æ–µ–≤–∞—è –°–∏—Å—Ç–µ–º–∞</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <!-- –í–ö–õ–ê–î–ö–ò -->
        <div class="tabs">
            <button class="tab-btn active" onclick="openTab('character')">üßô –ü–µ—Ä—Å–æ–Ω–∞–∂</button>
            <button class="tab-btn" onclick="openTab('combat')">‚öîÔ∏è –ë–æ–π</button>
            <button class="tab-btn" onclick="openTab('inventory')">üéí –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
            <button class="tab-btn" onclick="openTab('dice')">üé≤ –ö—É–±–∏–∫–∏</button>
            <button class="tab-btn" onclick="openTab('notes')">‚úçÔ∏è –ó–∞–º–µ—Ç–∫–∏</button>
        </div>

        <!-- –°–û–î–ï–†–ñ–ò–ú–û–ï –í–ö–õ–ê–î–û–ö -->
        <div id="character-tab" class="tab-content active">
            <h2 class="section-title">üßô –õ–∏—Å—Ç –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h2>
            <div id="character-container"></div>
        </div>

        <div id="combat-tab" class="tab-content">
            <h2 class="section-title">‚öîÔ∏è –ë–æ–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞</h2>
            <div id="combat-container"></div>
        </div>

        <div id="inventory-tab" class="tab-content">
            <h2 class="section-title">üéí –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</h2>
            <div id="inventory-container"></div>
        </div>

        <div id="dice-tab" class="tab-content">
            <h2 class="section-title">üé≤ –°–∏—Å—Ç–µ–º–∞ –∫—É–±–∏–∫–æ–≤</h2>
            <div id="dice-container"></div>
        </div>

        <div id="notes-tab" class="tab-content">
            <h2 class="section-title">‚úçÔ∏è –ó–∞–º–µ—Ç–∫–∏</h2>
            <div id="notes-container"></div>
        </div>
    </div>

    <!-- –ü–û–î–ö–õ–Æ–ß–ê–ï–ú –í–°–ï –°–ò–°–¢–ï–ú–´ -->
    <script src="character.js"></script>
    <script src="combat.js"></script>
    <script src="inventory.js"></script>
    <script src="dice.js"></script>
    <script src="notes.js"></script>
    
    <!-- –û–°–ù–û–í–ù–û–ô –°–ö–†–ò–ü–¢ -->
    <script>
        // –ë–ê–ó–û–í–´–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –í–ö–õ–ê–î–û–ö
        function openTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');
            event.currentTarget.classList.add('active');
            
            // –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤–∫–ª–∞–¥–∫–∏ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ—Ç–∫—Ä—ã—Ç–∏–∏
            if (tabName === 'character' && !window.characterLoaded) {
                renderCharacterSheet();
                window.characterLoaded = true;
            }
            if (tabName === 'inventory' && !window.inventoryLoaded) {
                initializeInventoryInterface();
                window.inventoryLoaded = true;
            }
            if (tabName === 'dice' && !window.diceLoaded) {
                initializeDiceSystem();
                window.diceLoaded = true;
            }
        }

        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –°–ò–°–¢–ï–ú–´
        function initializeSystem() {
            console.log('üéÆ D&D –°–∏—Å—Ç–µ–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞!');
            // –ü–µ—Ä—Å–æ–Ω–∞–∂ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –ø–µ—Ä–≤—ã–º
            renderCharacterSheet();
        }

        document.addEventListener('DOMContentLoaded', initializeSystem);
    </script>
</body>
</html>
/* styles.css - –ü–æ–ª–Ω—ã–π —Ñ–∞–π–ª —Å—Ç–∏–ª–µ–π –¥–ª—è D&D —Å–∏—Å—Ç–µ–º—ã */

/* –ë–ê–ó–û–í–´–ï –°–¢–ò–õ–ò */
* { 
    box-sizing: border-box; 
    margin: 0; 
    padding: 0; 
}

body { 
    font-family: 'Times New Roman', serif; 
    background: #1a0f0b; 
    color: #e0d0c0; 
    min-height: 100vh;
    overflow-x: hidden;
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

/* –°–¢–ò–õ–ò –í–ö–õ–ê–î–û–ö */
.tabs {
    display: flex;
    background: linear-gradient(to bottom, #5a3928, #3d2418);
    border-bottom: 2px solid #8b4513;
    flex-wrap: wrap;
    border-radius: 8px 8px 0 0;
}

.tab-btn {
    flex: 1;
    min-width: 120px;
    padding: 15px 10px;
    border: none;
    background: transparent;
    color: #e0d0c0;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s ease;
    border-right: 1px solid #8b4513;
    font-family: 'Times New Roman', serif;
}

.tab-btn:last-child { 
    border-right: none; 
}

.tab-btn:hover {
    background: #6b4423;
    text-shadow: 0 0 8px #ffd700;
}

.tab-btn.active { 
    background: #8b4513; 
    text-shadow: 0 0 10px #ffd700;
    font-weight: bold;
}

.tab-content { 
    display: none; 
    padding: 25px; 
    background: #2c1810;
    border: 2px solid #8b4513;
    border-top: none;
    border-radius: 0 0 8px 8px;
    min-height: 600px;
}

.tab-content.active { 
    display: block; 
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* –û–ë–©–ò–ï –°–¢–ò–õ–ò –ö–ù–û–ü–û–ö */
.btn {
    padding: 12px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    min-height: 44px;
    font-family: 'Times New Roman', serif;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.btn:active {
    transform: translateY(0);
}

.btn-plus { 
    background: linear-gradient(145deg, #27ae60, #2ecc71);
    color: white; 
    border: 1px solid #229954;
}

.btn-plus:hover {
    background: linear-gradient(145deg, #229954, #27ae60);
}

.btn-minus { 
    background: linear-gradient(145deg, #c44536, #e74c3c);
    color: white; 
    border: 1px solid #c0392b;
}

.btn-minus:hover {
    background: linear-gradient(145deg, #e74c3c, #c44536);
}

.btn-roll { 
    background: linear-gradient(145deg, #8b4513, #a0522d);
    color: white; 
    border: 1px solid #654321;
}

.btn-roll:hover {
    background: linear-gradient(145deg, #a0522d, #8b4513);
}

.btn-dice { 
    background: linear-gradient(145deg, #3498db, #2980b9);
    color: white; 
    margin: 5px;
    border: 1px solid #2471a3;
}

.btn-dice:hover {
    background: linear-gradient(145deg, #2980b9, #3498db);
}

.btn-small {
    padding: 8px 12px;
    font-size: 12px;
    min-height: 36px;
}

.btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none !important;
}

/* –ó–ê–ì–û–õ–û–í–ö–ò –°–ï–ö–¶–ò–ô */
.section-title {
    font-size: 1.8em;
    color: #d4af37;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 3px solid #8b4513;
    text-align: center;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    position: relative;
}

.section-title::after {
    content: '';
    position: absolute;
    bottom: -3px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 3px;
    background: #d4af37;
}

.skills-section {
    padding: 25px;
    border-bottom: 2px solid #5a3928;
    background: linear-gradient(145deg, #3d2418, #2c1810);
    margin-bottom: 20px;
    border-radius: 8px;
}

/* –§–û–†–ú–´ –ò –ò–ù–ü–£–¢–´ */
.input-group {
    margin-bottom: 20px;
}

.input-group label {
    display: block;
    margin-bottom: 8px;
    font-weight: bold;
    color: #d4af37;
    font-size: 1.1em;
}

input[type="text"],
input[type="number"],
input[type="email"],
input[type="password"],
select,
textarea {
    width: 100%;
    padding: 14px 16px;
    border: 2px solid #8b4513;
    border-radius: 6px;
    font-size: 16px;
    background: #1a0f0b;
    color: #e0d0c0;
    transition: all 0.3s ease;
    font-family: 'Times New Roman', serif;
}

input[type="text"]:focus,
input[type="number"]:focus,
select:focus,
textarea:focus {
    outline: none;
    border-color: #d4af37;
    box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
    background: #2c1810;
}

/* –°–¢–ê–¢–£–°–ù–´–ï –ü–ê–ù–ï–õ–ò */
.stat-panel {
    background: linear-gradient(145deg, #3d2418, #2c1810);
    padding: 20px;
    border-radius: 8px;
    border: 2px solid #5a3928;
    margin-bottom: 20px;
}

.stat-row {
    display: flex;
    align-items: center;
    padding: 15px 0;
    border-bottom: 1px solid #3d2418;
}

.stat-row:last-child {
    border-bottom: none;
}

.stat-label {
    flex: 1;
    font-weight: bold;
    display: flex;
    align-items: center;
    gap: 12px;
    color: #d4af37;
    font-size: 1.1em;
}

.stat-input {
    width: 100px;
    padding: 12px;
    border: 2px solid #8b4513;
    border-radius: 4px;
    text-align: center;
    font-size: 16px;
    background: #1a0f0b;
    color: #e0d0c0;
    font-weight: bold;
}

/* –ù–ê–í–´–ö–ò */
.skill-row {
    display: flex;
    align-items: center;
    padding: 18px 0;
    border-bottom: 1px solid #3d2418;
    transition: background-color 0.3s ease;
}

.skill-row:hover {
    background: rgba(139, 69, 19, 0.1);
    border-radius: 4px;
}

.skill-row:last-child {
    border-bottom: none;
}

.skill-name {
    flex: 2;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 15px;
    font-size: 1.1em;
}

.skill-controls {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 15px;
}

.skill-value {
    font-size: 1.4em;
    font-weight: bold;
    color: #d4af37;
    min-width: 50px;
    text-align: center;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}

/* –ò–ù–í–ï–ù–¢–ê–†–¨ */
.inventory-item {
    background: #2c1810;
    margin: 15px 0;
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #d4af37;
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.inventory-item:hover {
    transform: translateX(5px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

/* –ü–û–ü–ê–ü–´ –ò –ú–û–î–ê–õ–¨–ù–´–ï –û–ö–ù–ê */
.popup {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(26, 15, 11, 0.95);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
}

.popup-content {
    background: #2c1810;
    padding: 30px;
    border-radius: 12px;
    max-width: 95%;
    width: 500px;
    border: 3px solid #8b4513;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    animation: popupAppear 0.3s ease;
}

@keyframes popupAppear {
    from { 
        opacity: 0; 
        transform: scale(0.8) translateY(-20px); 
    }
    to { 
        opacity: 1; 
        transform: scale(1) translateY(0); 
    }
}

/* –ö–£–ë–ò–ö–ò */
.dice-container {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin: 25px 0;
    justify-content: center;
    align-items: center;
}

.dice {
    width: 60px;
    height: 60px;
    background: linear-gradient(145deg, #8b4513, #a0522d);
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.8em;
    font-weight: bold;
    color: #1a0f0b;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    border: 2px solid #654321;
    transition: transform 0.3s ease;
}

.dice:hover {
    transform: rotate(10deg) scale(1.1);
}

.dice-rolls {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 30px 0;
    flex-wrap: wrap;
}

/* –ü–û–õ–ï –ë–û–Ø */
.battlefield-container {
    min-height: 500px;
    background: #1a0f0b;
    border: 3px solid #5a3928;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 25px;
    position: relative;
    overflow: hidden;
}

.battlefield-hex {
    position: absolute;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    color: #e0d0c0;
}

.battlefield-hex:hover {
    filter: brightness(1.3);
    transform: scale(1.05);
    z-index: 100;
}

.battlefield-character {
    position: absolute;
    cursor: pointer;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: bold;
    color: #1a0f0b;
    transition: all 0.3s ease;
}

.battlefield-character:hover {
    transform: scale(1.2);
    z-index: 200;
}

/* –ó–ê–ú–ï–¢–ö–ò */
.note-item {
    background: #3d2418;
    margin: 15px 0;
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #27ae60;
    transition: all 0.3s ease;
}

.note-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.note-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.note-title {
    font-weight: bold;
    color: #d4af37;
    font-size: 1.2em;
}

.note-actions {
    display: flex;
    gap: 12px;
}

.note-preview {
    color: #b8a28a;
    font-size: 1em;
    line-height: 1.6;
}

/* –ü–û–ò–°–ö –ò –§–ò–õ–¨–¢–†–´ */
.search-box {
    width: 100%;
    padding: 14px 20px;
    margin: 15px 0;
    border: 2px solid #8b4513;
    border-radius: 25px;
    background: #1a0f0b;
    color: #e0d0c0;
    font-size: 16px;
    transition: all 0.3s ease;
}

.search-box:focus {
    outline: none;
    border-color: #d4af37;
    box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
}

/* –°–ö–†–û–õ–õ–ë–ê–†–´ */
::-webkit-scrollbar {
    width: 8px;
}

::-webkit-scrollbar-track {
    background: #2c1810;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: #8b4513;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #a0522d;
}

/* –ê–î–ê–ü–¢–ò–í–ù–û–°–¢–¨ */
@media (max-width: 768px) {
    .tabs { 
        flex-direction: column; 
    }
    
    .tab-btn { 
        min-width: 100%; 
        padding: 12px 8px;
        font-size: 14px;
    }
    
    .container { 
        padding: 10px; 
    }
    
    .tab-content {
        padding: 15px;
    }
    
    .section-title {
        font-size: 1.5em;
    }
    
    .skill-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .skill-controls {
        width: 100%;
        justify-content: space-between;
    }
    
    .stat-row {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
    }
    
    .popup-content {
        margin: 20px;
        padding: 20px;
    }
    
    .btn {
        padding: 10px 15px;
        font-size: 13px;
    }
}

@media (max-width: 480px) {
    .container {
        padding: 5px;
    }
    
    .tab-content {
        padding: 10px;
    }
    
    .section-title {
        font-size: 1.3em;
    }
    
    .dice {
        width: 50px;
        height: 50px;
        font-size: 1.5em;
    }
}

/* –£–¢–ò–õ–ò–¢–´ */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.mt-10 { margin-top: 10px; }
.mt-20 { margin-top: 20px; }
.mb-10 { margin-bottom: 10px; }
.mb-20 { margin-bottom: 20px; }

.p-10 { padding: 10px; }
.p-20 { padding: 20px; }

.hidden { display: none; }
.flex { display: flex; }
.grid { display: grid; }

.success { color: #27ae60; }
.warning { color: #f39c12; }
.error { color: #e74c3c; }
.info { color: #3498db; }

/* –ê–ù–ò–ú–ê–¶–ò–ò */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.pulse {
    animation: pulse 2s infinite;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

.shake {
    animation: shake 0.5s ease;
}

/* –¢–ï–ú–ù–´–ô –†–ï–ñ–ò–ú (—É–∂–µ —Ç–µ–º–Ω—ã–π, –Ω–æ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–æ–≤) */
.highlight {
    background: linear-gradient(145deg, #8b4513, #a0522d);
    color: #fff;
    padding: 5px 10px;
    border-radius: 4px;
    font-weight: bold;
}

.glow {
    box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
}

/* –ó–ê–ì–†–£–ó–û–ß–ù–´–ï –°–û–°–¢–û–Ø–ù–ò–Ø */
.loading {
    opacity: 0.7;
    pointer-events: none;
    position: relative;
}

.loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid #d4af37;
    border-top: 2px solid transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
// character.js - –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π D&D

// ========== –ö–û–ù–°–¢–ê–ù–¢–´ –ò –î–ê–ù–ù–´–ï ==========

const races = {
    human: { 
        name: "üë§ –ß–µ–ª–æ–≤–µ–∫", 
        description: "–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ä–∞—Å–∞, –±—ã—Å—Ç—Ä–∞—è –∞–¥–∞–ø—Ç–∞—Ü–∏—è", 
        lifespan: "80 –ª–µ—Ç",
        bonuses: { freePoints: 2 }
    },
    elf: { 
        name: "üåø –≠–ª—å—Ñ", 
        description: "–ú–∞–≥–∏—è –ø—Ä–∏—Ä–æ–¥—ã, –∏–∑—è—â–µ—Å—Ç–≤–æ –∏ –º—É–¥—Ä–æ—Å—Ç—å", 
        lifespan: "700 –ª–µ—Ç",
        bonuses: { magic: 2, perception: 1 }
    },
    dwarf: { 
        name: "‚õ∞Ô∏è –î–≤–∞—Ä—Ñ", 
        description: "–ö—É–∑–Ω–µ—á–Ω–æ–µ –¥–µ–ª–æ, —Å—Ç–æ–π–∫–æ—Å—Ç—å –∏ —Å–∏–ª–∞", 
        lifespan: "400 –ª–µ—Ç",
        bonuses: { endurance: 2, strength: 1 }
    },
    orc: { 
        name: "üí™ –û—Ä–∫", 
        description: "–°–∏–ª–∞, –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å –∏ –±–æ–µ–≤–æ–π –¥—É—Ö", 
        lifespan: "50 –ª–µ—Ç",
        bonuses: { strength: 2, endurance: 1 }
    },
    gnome: {
        name: "üîÆ –ì–Ω–æ–º",
        description: "–†–µ–º–µ—Å–ª–æ, –º–∞–≥–∏—è –∏ –∏–∑–æ–±—Ä–µ—Ç–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å",
        lifespan: "500 –ª–µ—Ç",
        bonuses: { craft: 2, magic: 1 }
    }
};

const skillsStructure = {
    "‚öîÔ∏è –ë–û–ï–í–´–ï –ù–ê–í–´–ö–ò": [
        "–¢—è–∂—ë–ª–∞—è –±—Ä–æ–Ω—è", "–õ—ë–≥–∫–∞—è –±—Ä–æ–Ω—è", "–î–≤—É—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ", 
        "–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ", "–°—Ç—Ä–µ–ª—å–±–∞", "–ë–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∏–µ", 
        "–î—Ä–µ–≤–∫–æ–≤–æ–µ", "–†—É–∫–æ–ø–∞—à–Ω—ã–π –±–æ–π", "–ú–µ—Ç–∞–Ω–∏–µ"
    ],
    "üé≠ –û–ë–©–ò–ï –ù–ê–í–´–ö–ò": [
        "–°–∫—Ä—ã—Ç–Ω–æ—Å—Ç—å", "–ö—Ä–∞—Å–Ω–æ—Ä–µ—á–∏–µ", "–õ–æ–≤–∫–æ—Å—Ç—å", "–í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å",
        "–í–∑–ª–æ–º", "–í–æ—Å–ø—Ä–∏—è—Ç–∏–µ", "–£–¥–∞—á–∞", "–ö–∞—Ä–º–∞–Ω–Ω—ã–µ –∫—Ä–∞–∂–∏"
    ],
    "‚öóÔ∏è –†–ï–ú–ï–°–õ–ê": [
        "–ê–ª—Ö–∏–º–∏—è", "–ö—É–∑–Ω–µ—á–Ω–æ–µ –¥–µ–ª–æ", "–ó–∞—á–∞—Ä–æ–≤–∞–Ω–∏–µ", "–†–µ–º–µ—Å–ª–æ"
    ],
    "üîÆ –ú–ê–ì–ò–Ø": [
        "–ú–∞–≥–∏—è –≤–æ–¥—ã", "–ú–∞–≥–∏—è –∑–µ–º–ª–∏", "–ú–∞–≥–∏—è –≤–æ–∑–¥—É—Ö–∞", "–ú–∞–≥–∏—è –∫—Ä–æ–≤–∏",
        "–ú–∞–≥–∏—è –æ–≥–Ω—è", "–ú–∞–≥–∏—è –º–µ—Ç–∞–ª–ª–∞", "–ú–∞–≥–∏—è –ø—Ä–∏—Ä–æ–¥—ã", "–ú–∞–≥–∏—è —Å–≤–µ—Ç–∞",
        "–ú–∞–≥–∏—è —Ç—å–º—ã", "–ú–∞–≥–∏—è –∏–Ω—Ñ–µ—Ä–Ω–æ", "–ú–∞–≥–∏—è —Ö–∞–æ—Å–∞", "–ú–∞–≥–∏—è —Ä–∞–∑—É–º–∞"
    ]
};

const levelTable = {
    0: { expRequired: 1000, hp: 100, mana: 100, stamina: 100, points: 20 },
    1: { expRequired: 3000, hp: 200, mana: 200, stamina: 200, points: 30 },
    2: { expRequired: 5000, hp: 300, mana: 300, stamina: 300, points: 40 },
    3: { expRequired: 8000, hp: 400, mana: 400, stamina: 400, points: 50 },
    4: { expRequired: 12000, hp: 500, mana: 500, stamina: 500, points: 60 },
    5: { expRequired: 16000, hp: 600, mana: 600, stamina: 600, points: 70 },
    6: { expRequired: 20000, hp: 700, mana: 700, stamina: 700, points: 80 },
    7: { expRequired: 25000, hp: 800, mana: 800, stamina: 800, points: 90 },
    8: { expRequired: 30000, hp: 900, mana: 900, stamina: 900, points: 100 },
    9: { expRequired: 100000, hp: 1000, mana: 1000, stamina: 1000, points: 200 }
};

// ========== –°–ò–°–¢–ï–ú–ê –•–†–ê–ù–ï–ù–ò–Ø ==========

class StorageSystem {
    static set(key, value) {
        try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
        } catch (e) {
            console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è:', e);
            return false;
        }
    }

    static get(key, defaultValue = null) {
        try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
        } catch (e) {
            console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:', e);
            return defaultValue;
        }
    }

    static remove(key) {
        try {
            localStorage.removeItem(key);
            return true;
        } catch (e) {
            console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è:', e);
            return false;
        }
    }
}

// ========== –ö–õ–ê–°–° –ü–ï–†–°–û–ù–ê–ñ–ê ==========

class Character {
    constructor(id = null) {
        this.id = id || 'char_' + Date.now();
        this.info = {
            name: '–ù–æ–≤—ã–π –ì–µ—Ä–æ–π',
            surname: '',
            title: '',
            race: 'human',
            heritage: '',
            height: '',
            weight: '',
            age: '',
            background: ''
        };
        this.level = {
            current: 0,
            exp: 0
        };
        this.stats = {
            health: 100,
            maxHealth: 100,
            mana: 100,
            maxMana: 100,
            stamina: 100,
            maxStamina: 100,
            freePoints: 20
        };
        this.skills = {};
        this.lockedSkills = {};
        this.availableMagicSchools = {};
        this.inventory = [];
        this.notes = [];
        this.createdAt = new Date().toISOString();
        this.updatedAt = new Date().toISOString();
        
        this.initializeSkills();
        this.applyRaceBonuses();
    }

    initializeSkills() {
        Object.values(skillsStructure).forEach(skillGroup => {
            skillGroup.forEach(skill => {
                this.skills[skill] = 5; // –ë–∞–∑–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            });
        });
    }

    applyRaceBonuses() {
        const race = races[this.info.race];
        if (race && race.bonuses) {
            if (race.bonuses.freePoints) {
                this.stats.freePoints += race.bonuses.freePoints;
            }
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ –±–æ–Ω—É—Å—ã —Ä–∞—Å—ã
        }
    }

    getSkillValue(skillName) {
        return this.skills[skillName] || 5;
    }

    setSkillValue(skillName, value) {
        this.skills[skillName] = Math.max(5, Math.min(100, value));
        this.updatedAt = new Date().toISOString();
    }

    addExperience(exp) {
        this.level.exp += exp;
        this.checkLevelUp();
        this.updatedAt = new Date().toISOString();
    }

    checkLevelUp() {
        if (this.level.current >= 9) return;

        const requiredExp = levelTable[this.level.current].expRequired;
        if (this.level.exp >= requiredExp) {
            this.level.current++;
            const levelData = levelTable[this.level.current];
            
            this.stats.maxHealth += levelData.hp;
            this.stats.maxMana += levelData.mana;
            this.stats.maxStamina += levelData.stamina;
            this.stats.freePoints += levelData.points;
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –ø—Ä–∏ –ø–æ–≤—ã—à–µ–Ω–∏–∏ —É—Ä–æ–≤–Ω—è
            this.stats.health = this.stats.maxHealth;
            this.stats.mana = this.stats.maxMana;
            this.stats.stamina = this.stats.maxStamina;
            
            this.level.exp -= requiredExp;
            
            console.log(`üéâ –£—Ä–æ–≤–µ–Ω—å –ø–æ–≤—ã—à–µ–Ω –¥–æ ${this.level.current}!`);
            return true;
        }
        return false;
    }

    changeRace(newRace) {
        if (races[newRace]) {
            // –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–µ –±–æ–Ω—É—Å—ã —Ä–∞—Å—ã
            const oldRace = races[this.info.race];
            if (oldRace && oldRace.bonuses) {
                if (oldRace.bonuses.freePoints) {
                    this.stats.freePoints -= oldRace.bonuses.freePoints;
                }
            }
            
            this.info.race = newRace;
            this.applyRaceBonuses();
            this.updatedAt = new Date().toISOString();
            return true;
        }
        return false;
    }

    save() {
        return StorageSystem.set(`character_${this.id}`, this);
    }

    static load(characterId) {
        const data = StorageSystem.get(`character_${characterId}`);
        if (!data) return null;
        
        const character = new Character();
        Object.assign(character, data);
        return character;
    }

    exportToJSON() {
        return JSON.stringify(this, null, 2);
    }

    static importFromJSON(jsonData) {
        try {
            const data = JSON.parse(jsonData);
            const character = new Character();
            Object.assign(character, data);
            character.updatedAt = new Date().toISOString();
            return character;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:', error);
            return null;
        }
    }
}

// ========== –°–ò–°–¢–ï–ú–ê –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ü–ï–†–°–û–ù–ê–ñ–ê–ú–ò ==========

class CharacterManager {
    constructor() {
        this.characters = {};
        this.currentCharacterId = null;
        this.loadCharacters();
    }

    loadCharacters() {
        this.characters = StorageSystem.get('dnd_characters', {});
        this.currentCharacterId = StorageSystem.get('current_character_id');
    }

    saveCharacters() {
        StorageSystem.set('dnd_characters', this.characters);
        StorageSystem.set('current_character_id', this.currentCharacterId);
    }

    createCharacter(name, race = 'human') {
        const character = new Character();
        character.info.name = name;
        character.info.race = race;
        
        this.characters[character.id] = character;
        this.currentCharacterId = character.id;
        this.saveCharacters();
        
        return character;
    }

    getCurrentCharacter() {
        if (!this.currentCharacterId || !this.characters[this.currentCharacterId]) {
            return null;
        }
        return this.characters[this.currentCharacterId];
    }

    switchCharacter(characterId) {
        if (this.characters[characterId]) {
            this.currentCharacterId = characterId;
            this.saveCharacters();
            return true;
        }
        return false;
    }

    deleteCharacter(characterId) {
        if (this.characters[characterId]) {
            // –£–¥–∞–ª—è–µ–º –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
            StorageSystem.remove(`inventory_${characterId}`);
            
            delete this.characters[characterId];
            
            if (this.currentCharacterId === characterId) {
                const remainingIds = Object.keys(this.characters);
                this.currentCharacterId = remainingIds.length > 0 ? remainingIds[0] : null;
            }
            
            this.saveCharacters();
            return true;
        }
        return false;
    }

    getCharacterList() {
        return Object.values(this.characters).map(char => ({
            id: char.id,
            name: char.info.name,
            race: char.info.race,
            level: char.level.current,
            createdAt: char.createdAt
        }));
    }

    exportAllCharacters() {
        return JSON.stringify(this.characters, null, 2);
    }

    importCharacters(jsonData) {
        try {
            const importedChars = JSON.parse(jsonData);
            let importedCount = 0;
            
            Object.values(importedChars).forEach(charData => {
                if (charData.info && charData.info.name) {
                    const newId = 'char_import_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    this.characters[newId] = charData;
                    this.characters[newId].id = newId;
                    this.characters[newId].updatedAt = new Date().toISOString();
                    importedCount++;
                }
            });
            
            this.saveCharacters();
            return importedCount;
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π:', error);
            return 0;
        }
    }
}

// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========

let characterManager = new CharacterManager();
let currentCharacter = characterManager.getCurrentCharacter();

// ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –û–¢–û–ë–†–ê–ñ–ï–ù–ò–Ø ==========

function renderCharacterSheet() {
    const container = document.getElementById('character-container');
    if (!container) return;

    if (!currentCharacter) {
        container.innerHTML = `
            <div class="text-center" style="padding: 50px;">
                <h3 style="color: #8b7d6b;">–ü–µ—Ä—Å–æ–Ω–∞–∂ –Ω–µ –≤—ã–±—Ä–∞–Ω</h3>
                <button class="btn btn-plus" onclick="createNewCharacter()">–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</button>
            </div>
        `;
        return;
    }

    container.innerHTML = `
        <div class="stat-panel">
            <div class="header" style="background: linear-gradient(to bottom, #3d2418, #2c1810); 
                  color: #e0d0c0; padding: 25px; text-align: center; border-bottom: 3px solid #8b4513;">
                <h1 style="font-size: 2.2em; color: #d4af37; margin-bottom: 20px;">üßô ${currentCharacter.info.name}</h1>
                
                <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center;">
                    <div class="input-group">
                        <label>–ò–º—è –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:</label>
                        <input type="text" id="characterName" value="${currentCharacter.info.name}" 
                               placeholder="–í–≤–µ–¥–∏—Ç–µ –∏–º—è" class="stat-input" style="width: 200px;">
                    </div>
                    <div class="input-group">
                        <label>–†–∞—Å–∞:</label>
                        <select id="characterRace" class="stat-input" style="width: 200px;">
                            ${Object.entries(races).map(([id, race]) => 
                                `<option value="${id}" ${currentCharacter.info.race === id ? 'selected' : ''}>${race.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>

                <div style="display: flex; gap: 15px; margin-bottom: 15px; flex-wrap: wrap; justify-content: center;">
                    <div class="input-group">
                        <label>–£—Ä–æ–≤–µ–Ω—å:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span id="currentLevel" style="font-size: 1.3em; font-weight: bold; color: #d4af37;">${currentCharacter.level.current}</span>
                            <button class="btn btn-roll" onclick="editLevel()">‚úèÔ∏è</button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label>–û–ø—ã—Ç:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="number" id="currentExp" class="stat-input" value="${currentCharacter.level.exp}" 
                                   style="width: 120px;">
                            <span style="color: #d4af37; font-weight: bold;">/ 
                                <span id="requiredExp">${currentCharacter.level.current < 9 ? levelTable[currentCharacter.level.current].expRequired : 'MAX'}</span>
                            </span>
                            <button class="btn btn-plus" onclick="addExperience()">‚ûï</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="stat-panel">
            <h3 style="color: #d4af37; margin-bottom: 20px;">‚ù§Ô∏è –û—Å–Ω–æ–≤–Ω—ã–µ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏</h3>
            
            <div class="stat-row">
                <div class="stat-label">‚ù§Ô∏è –ó–¥–æ—Ä–æ–≤—å–µ:</div>
                <input type="number" class="stat-input" id="health" value="${currentCharacter.stats.health}" 
                       min="0" max="${currentCharacter.stats.maxHealth}">
                <button class="btn btn-minus" onclick="changeStat('health', -10)">-10</button>
                <button class="btn btn-plus" onclick="changeStat('health', 10)">+10</button>
                <span style="color: #8b7d6b;">/ ${currentCharacter.stats.maxHealth}</span>
            </div>

            <div class="stat-row">
                <div class="stat-label">üîÆ –ú–∞–Ω–∞:</div>
                <input type="number" class="stat-input" id="mana" value="${currentCharacter.stats.mana}" 
                       min="0" max="${currentCharacter.stats.maxMana}">
                <button class="btn btn-minus" onclick="changeStat('mana', -10)">-10</button>
                <button class="btn btn-plus" onclick="changeStat('mana', 10)">+10</button>
                <span style="color: #8b7d6b;">/ ${currentCharacter.stats.maxMana}</span>
            </div>

            <div class="stat-row">
                <div class="stat-label">‚ö° –í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å:</div>
                <input type="number" class="stat-input" id="stamina" value="${currentCharacter.stats.stamina}" 
                       min="0" max="${currentCharacter.stats.maxStamina}">
                <button class="btn btn-minus" onclick="changeStat('stamina', -10)">-10</button>
                <button class="btn btn-plus" onclick="changeStat('stamina', 10)">+10</button>
                <span style="color: #8b7d6b;">/ ${currentCharacter.stats.maxStamina}</span>
            </div>

            <div class="stat-row">
                <div class="stat-label">üéØ –°–≤–æ–±–æ–¥–Ω—ã–µ –æ—á–∫–∏:</div>
                <input type="number" class="stat-input" id="freePoints" value="${currentCharacter.stats.freePoints}" 
                       min="0" style="width: 80px;">
                <button class="btn btn-roll" onclick="saveFreePoints()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            </div>
        </div>

        <div class="skills-section">
            <h3 class="section-title">üéØ –ù–∞–≤—ã–∫–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</h3>
            <div id="skillsContainer">
                ${renderSkills()}
            </div>
        </div>

        <div style="text-align: center; margin: 20px 0;">
            <button class="btn btn-plus" onclick="saveCharacterData()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞</button>
            <button class="btn btn-roll" onclick="exportCharacter()">üì§ –≠–∫—Å–ø–æ—Ä—Ç</button>
            <button class="btn btn-roll" onclick="showLevelsTable()">üìä –¢–∞–±–ª–∏—Ü–∞ —É—Ä–æ–≤–Ω–µ–π</button>
        </div>
    `;

    setupCharacterEventListeners();
}

function renderSkills() {
    if (!currentCharacter) return '';

    let skillsHTML = '';
    for (const [groupName, skills] of Object.entries(skillsStructure)) {
        skillsHTML += `<h4 style="color: #d4af37; margin: 20px 0 15px 0; font-size: 1.2em;">${groupName}</h4>`;
        
        skills.forEach(skill => {
            const skillValue = currentCharacter.getSkillValue(skill);
            const isLocked = currentCharacter.lockedSkills[skill] || false;
            const lockBtnText = isLocked ? 'üîì' : 'üîí';
            const lockBtnClass = isLocked ? 'btn-lock locked' : 'btn-lock';

            skillsHTML += `
                <div class="skill-row" style="${isLocked ? 'opacity: 0.6;' : ''}">
                    <div class="skill-name">
                        <span>üéØ</span>
                        <span>${skill}</span>
                    </div>
                    <div class="skill-controls">
                        <button class="btn btn-minus" onclick="decreaseSkill('${skill}')" 
                                ${isLocked || skillValue <= 5 ? 'disabled' : ''}>-</button>
                        <span class="skill-value">${skillValue}</span>
                        <button class="btn btn-plus" onclick="increaseSkill('${skill}')" 
                                ${isLocked || currentCharacter.stats.freePoints <= 0 ? 'disabled' : ''}>+</button>
                        <button class="btn ${lockBtnClass}" onclick="toggleSkillLock('${skill}')" 
                                style="background: #95a5a6; ${isLocked ? 'background: #e74c3c;' : ''}">
                            ${lockBtnText}
                        </button>
                        <button class="btn btn-roll" onclick="rollSkill('${skill}')" ${isLocked ? 'disabled' : ''}>
                            üé≤ –ë—Ä–æ—Å–æ–∫
                        </button>
                    </div>
                </div>
            `;
        });
    }
    return skillsHTML;
}

// ========== –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø ==========

function setupCharacterEventListeners() {
    const inputs = ['characterName', 'characterRace', 'health', 'mana', 'stamina', 'freePoints', 'currentExp'];
    
    inputs.forEach(inputId => {
        const element = document.getElementById(inputId);
        if (element) {
            element.addEventListener('change', saveCharacterData);
            element.addEventListener('input', saveCharacterData);
        }
    });
}

function saveCharacterData() {
    if (!currentCharacter) return;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    currentCharacter.info.name = document.getElementById('characterName').value;
    const newRace = document.getElementById('characterRace').value;
    if (newRace !== currentCharacter.info.race) {
        currentCharacter.changeRace(newRace);
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏
    currentCharacter.stats.health = parseInt(document.getElementById('health').value) || 0;
    currentCharacter.stats.mana = parseInt(document.getElementById('mana').value) || 0;
    currentCharacter.stats.stamina = parseInt(document.getElementById('stamina').value) || 0;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–ø—ã—Ç
    currentCharacter.level.exp = parseInt(document.getElementById('currentExp').value) || 0;
    currentCharacter.checkLevelUp();

    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    updateLevelDisplay();
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
    currentCharacter.save();
    characterManager.saveCharacters();
}

function saveFreePoints() {
    if (!currentCharacter) return;
    const newPoints = parseInt(document.getElementById('freePoints').value) || 0;
    currentCharacter.stats.freePoints = newPoints;
    currentCharacter.save();
    characterManager.saveCharacters();
    renderCharacterSheet();
}

function changeStat(stat, value) {
    if (!currentCharacter) return;
    
    const input = document.getElementById(stat);
    let currentValue = parseInt(input.value) || 0;
    let newValue = currentValue + value;
    
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
    const maxStat = currentCharacter.stats['max' + stat.charAt(0).toUpperCase() + stat.slice(1)];
    if (newValue < 0) newValue = 0;
    if (newValue > maxStat) newValue = maxStat;
    
    input.value = newValue;
    currentCharacter.stats[stat] = newValue;
    currentCharacter.save();
}

function increaseSkill(skillName) {
    if (!currentCharacter) return;

    if (currentCharacter.stats.freePoints > 0) {
        const currentValue = currentCharacter.getSkillValue(skillName);
        currentCharacter.setSkillValue(skillName, currentValue + 1);
        currentCharacter.stats.freePoints--;
        currentCharacter.save();
        renderCharacterSheet();
    }
}

function decreaseSkill(skillName) {
    if (!currentCharacter) return;

    const currentValue = currentCharacter.getSkillValue(skillName);
    if (currentValue > 5) {
        currentCharacter.setSkillValue(skillName, currentValue - 1);
        currentCharacter.stats.freePoints++;
        currentCharacter.save();
        renderCharacterSheet();
    }
}

function toggleSkillLock(skillName) {
    if (!currentCharacter) return;

    const currentlyLocked = currentCharacter.lockedSkills[skillName] || false;
    
    if (currentlyLocked) {
        currentCharacter.lockedSkills[skillName] = false;
        currentCharacter.save();
        renderCharacterSheet();
    } else {
        currentCharacter.lockedSkills[skillName] = true;
        currentCharacter.save();
        renderCharacterSheet();
    }
}

function addExperience() {
    if (!currentCharacter) return;
    
    const expToAdd = prompt('–°–∫–æ–ª—å–∫–æ –æ–ø—ã—Ç–∞ –¥–æ–±–∞–≤–∏—Ç—å?', '1000');
    if (expToAdd && !isNaN(expToAdd)) {
        currentCharacter.addExperience(parseInt(expToAdd));
        updateLevelDisplay();
        renderCharacterSheet();
    }
}

function editLevel() {
    if (!currentCharacter) return;
    
    const newLevel = prompt('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å (0-9):', currentCharacter.level.current);
    if (newLevel && !isNaN(newLevel) && newLevel >= 0 && newLevel <= 9) {
        currentCharacter.level.current = parseInt(newLevel);
        updateStatsForLevel();
        updateLevelDisplay();
        currentCharacter.save();
        renderCharacterSheet();
    }
}

function updateStatsForLevel() {
    if (!currentCharacter) return;
    
    let totalHP = 100, totalMana = 100, totalStamina = 100;
    
    for (let i = 0; i <= currentCharacter.level.current; i++) {
        totalHP += levelTable[i].hp;
        totalMana += levelTable[i].mana;
        totalStamina += levelTable[i].stamina;
    }
    
    currentCharacter.stats.maxHealth = totalHP;
    currentCharacter.stats.maxMana = totalMana;
    currentCharacter.stats.maxStamina = totalStamina;
    currentCharacter.stats.health = totalHP;
    currentCharacter.stats.mana = totalMana;
    currentCharacter.stats.stamina = totalStamina;
}

function updateLevelDisplay() {
    if (!currentCharacter) return;
    
    const levelElement = document.getElementById('currentLevel');
    const expElement = document.getElementById('currentExp');
    const requiredElement = document.getElementById('requiredExp');
    
    if (levelElement) levelElement.textContent = currentCharacter.level.current;
    if (expElement) expElement.value = currentCharacter.level.exp;
    
    if (currentCharacter.level.current < 9) {
        if (requiredElement) requiredElement.textContent = levelTable[currentCharacter.level.current].expRequired;
    } else {
        if (requiredElement) requiredElement.textContent = 'MAX';
    }
}

function rollSkill(skillName) {
    if (!currentCharacter) return;
    
    const skillValue = currentCharacter.getSkillValue(skillName);
    const check = rollSkillCheck(skillValue);
    
    let resultText, resultClass;
    if (check.critical === 'success') {
        resultText = "üí´ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –£–°–ü–ï–•!";
        resultClass = "success";
    } else if (check.critical === 'failure') {
        resultText = "üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ü–†–û–í–ê–õ!";
        resultClass = "error";
    } else if (check.success) {
        resultText = "‚úÖ –£–°–ü–ï–•!";
        resultClass = "success";
    } else {
        resultText = "‚ùå –ù–ï–£–î–ê–ß–ê!";
        resultClass = "error";
    }

    showRollResult(skillName, skillValue, check.roll, check.total, resultText, resultClass);
}

function showRollResult(skillName, skillValue, dice, total, resultText, resultClass) {
    const popup = document.createElement('div');
    popup.className = 'popup';
    popup.innerHTML = `
        <div class="popup-content">
            <h2 style="color: #d4af37; margin-bottom: 20px;">–ë—Ä–æ—Å–æ–∫ –Ω–∞ "${skillName}" (${skillValue})</h2>
            
            <div class="dice-rolls">
                <div class="dice">${dice[0]}</div>
            </div>
            
            <div style="font-size: 1.5em; margin: 20px 0; color: #e0d0c0;">
                –†–µ–∑—É–ª—å—Ç–∞—Ç: <strong>${total}</strong>
            </div>
            
            <div class="${resultClass}" style="font-weight: bold; font-size: 1.3em; margin: 20px 0;">
                ${resultText}
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="btn btn-roll" onclick="rollSkill('${skillName}'); this.closest('.popup').remove();">üé≤ –ö–∏–Ω—É—Ç—å –µ—â–µ</button>
                <button class="btn btn-roll" onclick="this.closest('.popup').remove();">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(popup);
}

function showLevelsTable() {
    if (!currentCharacter) return;
    
    let tableHTML = `
        <h3 style="color: #d4af37; margin-bottom: 15px;">üìä –¢–∞–±–ª–∏—Ü–∞ —É—Ä–æ–≤–Ω–µ–π</h3>
        <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
            <tr>
                <th style="padding: 10px; border: 1px solid #5a3928; background: #3d2418; color: #d4af37;">–£—Ä.</th>
                <th style="padding: 10px; border: 1px solid #5a3928; background: #3d2418; color: #d4af37;">–û–ø—ã—Ç</th>
                <th style="padding: 10px; border: 1px solid #5a3928; background: #3d2418; color: #d4af37;">–•–ü</th>
                <th style="padding: 10px; border: 1px solid #5a3928; background: #3d2418; color: #d4af37;">–ú–∞–Ω–∞</th>
                <th style="padding: 10px; border: 1px solid #5a3928; background: #3d2418; color: #d4af37;">–û—á–∫–∏</th>
            </tr>
    `;
    
    for (let level = 0; level <= 9; level++) {
        const data = levelTable[level];
        const isCurrent = level === currentCharacter.level.current;
        
        tableHTML += `
            <tr style="${isCurrent ? 'background: #8b4513; font-weight: bold;' : ''}">
                <td style="padding: 10px; border: 1px solid #5a3928; text-align: center;">${level}</td>
                <td style="padding: 10px; border: 1px solid #5a3928; text-align: center;">${data.expRequired || 'MAX'}</td>
                <td style="padding: 10px; border: 1px solid #5a3928; text-align: center;">+${data.hp}</td>
                <td style="padding: 10px; border: 1px solid #5a3928; text-align: center;">+${data.mana}</td>
                <td style="padding: 10px; border: 1px solid #5a3928; text-align: center;">+${data.points}</td>
            </tr>
        `;
    }
    
    tableHTML += `</table>`;
    
    const popup = document.createElement('div');
    popup.className = 'popup';
    popup.innerHTML = `
        <div class="popup-content">
            ${tableHTML}
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn btn-roll" onclick="this.closest('.popup').remove();">–ó–∞–∫—Ä—ã—Ç—å</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(popup);
}

function exportCharacter() {
    if (!currentCharacter) return;
    
    const dataStr = currentCharacter.exportToJSON();
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `character_${currentCharacter.info.name || 'unknown'}.json`;
    link.click();
}

function createNewCharacter() {
    const name = prompt('–í–≤–µ–¥–∏—Ç–µ –∏–º—è –Ω–æ–≤–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞:', '–ù–æ–≤—ã–π –ì–µ—Ä–æ–π');
    if (name && name.trim()) {
        const character = characterManager.createCharacter(name.trim());
        currentCharacter = character;
        renderCharacterSheet();
    }
}

// ========== –°–ò–°–¢–ï–ú–ê –ö–£–ë–ò–ö–û–í –î–õ–Ø –ü–ï–†–°–û–ù–ê–ñ–ê ==========

function rollSkillCheck(skillValue, modifiers = 0) {
    const roll = rollDice(20, 1);
    const totalRoll = roll.total + modifiers;
    const success = totalRoll >= skillValue;
    
    let critical = 'normal';
    if (roll.total === 20) critical = 'success';
    if (roll.total === 1) critical = 'failure';
    
    return {
        roll: roll.results,
        total: totalRoll,
        success: success,
        critical: critical
    };
}

function rollDice(sides, count = 1) {
    let results = [];
    let total = 0;
    
    for (let i = 0; i < count; i++) {
        const result = Math.floor(Math.random() * sides) + 1;
        results.push(result);
        total += result;
    }
    
    return { results, total };
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Ñ–ª–∞–≥–∏ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∑–∞–≥—Ä—É–∑–∫–∏
window.characterLoaded = false;

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
window.getCurrentCharacter = function() {
    return currentCharacter;
};

console.log('‚úÖ character.js –∑–∞–≥—Ä—É–∂–µ–Ω!');
        // combat.js - –ü–æ–ª–Ω–∞—è –±–æ–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ D&D

// ========== –ì–ï–ö–°–ê–ì–û–ù–ê–õ–¨–ù–û–ï –ü–û–õ–ï –ë–û–Ø ==========

class HexagonalBattlefield {
    constructor(width = 15, height = 10) {
        this.width = width;
        this.height = height;
        this.cells = {};
        this.obstacles = {};
        this.characters = {};
        this.hexSize = 40;
        this.initializeGrid();
    }

    initializeGrid() {
        for (let q = 0; q < this.width; q++) {
            for (let r = 0; r < this.height; r++) {
                const cellId = this.getCellId(q, r);
                this.cells[cellId] = {
                    q: q,
                    r: r,
                    type: 'empty',
                    occupied: false,
                    visible: true
                };
            }
        }
    }

    getCellId(q, r) {
        return `hex_${q}_${r}`;
    }

    getCellCoordinates(cellId) {
        const [_, q, r] = cellId.split('_');
        return { q: parseInt(q), r: parseInt(r) };
    }

    hexToPixel(q, r) {
        const x = this.hexSize * Math.sqrt(3) * (q + r / 2);
        const y = this.hexSize * 3/2 * r;
        return { x, y };
    }

    getNeighbors(q, r) {
        const directions = [
            [1, 0], [1, -1], [0, -1],
            [-1, 0], [-1, 1], [0, 1]
        ];
        
        const neighbors = [];
        for (const [dq, dr] of directions) {
            const nq = q + dq;
            const nr = r + dr;
            if (this.isValidCell(nq, nr)) {
                neighbors.push(this.getCellId(nq, nr));
            }
        }
        return neighbors;
    }

    isValidCell(q, r) {
        return q >= 0 && q < this.width && r >= 0 && r < this.height;
    }

    calculateDistance(cellId1, cellId2) {
        const coords1 = this.getCellCoordinates(cellId1);
        const coords2 = this.getCellCoordinates(cellId2);
        
        return (Math.abs(coords1.q - coords2.q) + 
                Math.abs(coords1.q + coords1.r - coords2.q - coords2.r) + 
                Math.abs(coords1.r - coords2.r)) / 2;
    }

    addObstacle(cellId, type = 'tree') {
        if (this.cells[cellId]) {
            this.cells[cellId].type = type;
            this.cells[cellId].occupied = true;
            this.obstacles[cellId] = { type, cellId };
        }
    }

    removeObstacle(cellId) {
        if (this.cells[cellId]) {
            this.cells[cellId].type = 'empty';
            this.cells[cellId].occupied = false;
            delete this.obstacles[cellId];
        }
    }

    placeCharacter(characterId, cellId) {
        if (this.cells[cellId] && !this.cells[cellId].occupied) {
            this.removeCharacter(characterId);
            
            this.cells[cellId].occupied = true;
            this.characters[characterId] = {
                cellId: cellId,
                characterId: characterId
            };
            return true;
        }
        return false;
    }

    removeCharacter(characterId) {
        if (this.characters[characterId]) {
            const cellId = this.characters[characterId].cellId;
            if (this.cells[cellId]) {
                this.cells[cellId].occupied = false;
            }
            delete this.characters[characterId];
        }
    }

    moveCharacter(characterId, targetCellId) {
        if (!this.characters[characterId]) return false;
        
        const currentCellId = this.characters[characterId].cellId;
        const distance = this.calculateDistance(currentCellId, targetCellId);
        
        if (distance <= 1 && this.placeCharacter(characterId, targetCellId)) {
            return true;
        }
        return false;
    }

    getCharacterPosition(characterId) {
        return this.characters[characterId];
    }
}

// ========== –í–ò–ó–£–ê–õ–ò–ó–ê–¶–ò–Ø –ü–û–õ–Ø –ë–û–Ø ==========

class BattlefieldRenderer {
    constructor(battlefield, containerId) {
        this.battlefield = battlefield;
        this.container = document.getElementById(containerId);
        this.selectedCell = null;
        this.selectedCharacter = null;
    }

    render() {
        if (!this.container) return;

        this.container.innerHTML = '';
        this.container.style.position = 'relative';
        this.container.style.width = `${this.battlefield.width * this.battlefield.hexSize * 1.8}px`;
        this.container.style.height = `${this.battlefield.height * this.battlefield.hexSize * 1.8}px`;
        this.container.style.background = '#1a0f0b';
        this.container.style.border = '2px solid #8b4513';
        this.container.style.borderRadius = '8px';
        this.container.style.overflow = 'hidden';

        for (const cellId in this.battlefield.cells) {
            this.renderHex(cellId);
        }

        for (const characterId in this.battlefield.characters) {
            this.renderCharacter(characterId);
        }
    }

    renderHex(cellId) {
        const cell = this.battlefield.cells[cellId];
        const { x, y } = this.battlefield.hexToPixel(cell.q, cell.r);
        
        const hexElement = document.createElement('div');
        hexElement.id = `hex_${cellId}`;
        hexElement.className = 'battlefield-hex';
        hexElement.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: ${this.battlefield.hexSize * 2}px;
            height: ${this.battlefield.hexSize * 2}px;
            background: ${this.getHexColor(cell)};
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            border: 1px solid #5a3928;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #e0d0c0;
        `;

        hexElement.innerHTML = this.getHexContent(cell);
        hexElement.addEventListener('click', () => this.onHexClick(cellId));
        hexElement.addEventListener('mouseenter', () => this.onHexHover(cellId));
        hexElement.addEventListener('mouseleave', () => this.onHexLeave(cellId));

        this.container.appendChild(hexElement);
    }

    getHexColor(cell) {
        if (cell.occupied && cell.type !== 'empty') {
            switch (cell.type) {
                case 'tree': return '#2d5a27';
                case 'rock': return '#5a5a5a';
                case 'building': return '#8b4513';
                default: return '#3d2418';
            }
        }
        return cell.occupied ? '#5a3928' : '#2c1810';
    }

    getHexContent(cell) {
        if (cell.occupied && cell.type !== 'empty') {
            switch (cell.type) {
                case 'tree': return 'üå≤';
                case 'rock': return 'ü™®';
                case 'building': return 'üè†';
            }
        }
        return '';
    }

    renderCharacter(characterId) {
        const character = this.battlefield.characters[characterId];
        const cell = this.battlefield.cells[character.cellId];
        const { x, y } = this.battlefield.hexToPixel(cell.q, cell.r);
        
        const charElement = document.createElement('div');
        charElement.id = `char_${characterId}`;
        charElement.className = 'battlefield-character';
        charElement.style.cssText = `
            position: absolute;
            left: ${x + this.battlefield.hexSize * 0.5}px;
            top: ${y + this.battlefield.hexSize * 0.5}px;
            width: ${this.battlefield.hexSize}px;
            height: ${this.battlefield.hexSize}px;
            background: #d4af37;
            border: 2px solid #8b4513;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #1a0f0b;
        `;

        const charSymbol = this.getCharacterSymbol(characterId);
        charElement.innerHTML = charSymbol;
        charElement.title = `–ü–µ—Ä—Å–æ–Ω–∞–∂: ${characterId}`;
        
        charElement.addEventListener('click', (e) => {
            e.stopPropagation();
            this.onCharacterClick(characterId);
        });

        this.container.appendChild(charElement);
    }

    getCharacterSymbol(characterId) {
        if (characterId.startsWith('player')) return 'üë§';
        if (characterId.startsWith('farmer')) return 'üë®‚Äçüåæ';
        if (characterId.startsWith('bandit')) return 'üíÄ';
        if (characterId.startsWith('archer')) return 'üèπ';
        if (characterId.startsWith('mage')) return 'üßô‚Äç‚ôÇÔ∏è';
        return '‚öîÔ∏è';
    }

    onHexClick(cellId) {
        if (this.selectedCharacter) {
            if (this.battlefield.moveCharacter(this.selectedCharacter, cellId)) {
                this.render();
            }
            this.selectedCharacter = null;
            this.resetHighlights();
        } else {
            this.selectedCell = cellId;
            this.highlightCell(cellId);
        }
    }

    onHexHover(cellId) {
        this.highlightCell(cellId, true);
    }

    onHexLeave(cellId) {
        this.highlightCell(cellId, false);
    }

    onCharacterClick(characterId) {
        this.selectedCharacter = characterId;
        this.highlightPossibleMoves(characterId);
    }

    highlightCell(cellId, isHover = false) {
        const hexElement = document.getElementById(`hex_${cellId}`);
        if (hexElement) {
            if (isHover) {
                hexElement.style.filter = 'brightness(1.3)';
                hexElement.style.borderColor = '#d4af37';
            } else {
                hexElement.style.filter = 'brightness(1)';
                hexElement.style.borderColor = '#5a3928';
            }
        }
    }

    highlightPossibleMoves(characterId) {
        const character = this.battlefield.characters[characterId];
        if (!character) return;

        const currentCellId = character.cellId;
        const neighbors = this.battlefield.getNeighbors(
            this.battlefield.getCellCoordinates(currentCellId).q,
            this.battlefield.getCellCoordinates(currentCellId).r
        );

        this.resetHighlights();

        neighbors.forEach(cellId => {
            const hexElement = document.getElementById(`hex_${cellId}`);
            if (hexElement && !this.battlefield.cells[cellId].occupied) {
                hexElement.style.background = '#27ae60';
                hexElement.style.borderColor = '#2ecc71';
            }
        });

        const currentHex = document.getElementById(`hex_${currentCellId}`);
        if (currentHex) {
            currentHex.style.background = '#3498db';
            currentHex.style.borderColor = '#2980b9';
        }
    }

    resetHighlights() {
        const allHexes = document.querySelectorAll('.battlefield-hex');
        allHexes.forEach(hex => {
            const cellId = hex.id.replace('hex_', '');
            const cell = this.battlefield.cells[cellId];
            hex.style.background = this.getHexColor(cell);
            hex.style.borderColor = '#5a3928';
        });
    }
}

// ========== –°–ò–°–¢–ï–ú–ê –õ–ê–ù–î–®–ê–§–¢–û–í ==========

const landscapes = {
    forest: {
        name: "üå≤ –õ–µ—Å", 
        obstacles: [
            { type: 'tree', density: 0.4 },
            { type: 'rock', density: 0.1 }
        ],
        description: "–ü–ª–æ—Ç–Ω–∞—è —Ä–∞—Å—Ç–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å"
    },
    city: {
        name: "üèôÔ∏è –ì–æ—Ä–æ–¥",
        obstacles: [
            { type: 'building', density: 0.3 },
            { type: 'tree', density: 0.1 }
        ],
        description: "–£–∑–∫–∏–µ —É–ª–∏—Ü—ã"
    },
    plains: {
        name: "üåæ –†–∞–≤–Ω–∏–Ω—ã",
        obstacles: [
            { type: 'tree', density: 0.05 },
            { type: 'rock', density: 0.02 }
        ],
        description: "–û—Ç–∫—Ä—ã—Ç–∞—è –º–µ—Å—Ç–Ω–æ—Å—Ç—å"
    }
};

function generateLandscape(battlefield, landscapeType) {
    const landscape = landscapes[landscapeType];
    if (!landscape) return;

    for (const cellId in battlefield.obstacles) {
        battlefield.removeObstacle(cellId);
    }

    for (let q = 0; q < battlefield.width; q++) {
        for (let r = 0; r < battlefield.height; r++) {
            const cellId = battlefield.getCellId(q, r);
            
            if (q < 2 || q >= battlefield.width - 2 || r < 2 || r >= battlefield.height - 2) {
                continue;
            }

            for (const obstacle of landscape.obstacles) {
                if (Math.random() < obstacle.density) {
                    battlefield.addObstacle(cellId, obstacle.type);
                    break;
                }
            }
        }
    }
}

// ========== –°–ò–°–¢–ï–ú–ê –ë–û–Ø ==========

class CombatSystem {
    constructor(battlefield) {
        this.battlefield = battlefield;
        this.combatants = {};
        this.currentTurn = 0;
        this.activeCombatant = null;
        this.combatHistory = [];
        this.isCombatActive = false;
    }

    addCombatant(characterId, type, stats = {}) {
        this.combatants[characterId] = {
            id: characterId,
            type: type,
            stats: {
                health: stats.health || 100,
                maxHealth: stats.maxHealth || 100,
                skills: stats.skills || {}
            },
            position: this.battlefield.getCharacterPosition(characterId)
        };
    }

    startCombat() {
        this.isCombatActive = true;
        this.currentTurn = 1;
        this.determineInitiative();
        this.nextTurn();
        
        this.addToCombatHistory(`‚öîÔ∏è –ë–æ–π –Ω–∞—á–∞–ª—Å—è!`);
        this.updateBattleInfo();
    }

    determineInitiative() {
        const combatantIds = Object.keys(this.combatants);
        this.turnOrder = combatantIds.sort((a, b) => {
            if (a.startsWith('player')) return -1;
            if (b.startsWith('player')) return 1;
            return Math.random() - 0.5;
        });
    }

    nextTurn() {
        if (!this.isCombatActive) return;

        if (!this.activeCombatant || !this.turnOrder.includes(this.activeCombatant)) {
            this.activeCombatant = this.turnOrder[0];
        } else {
            const currentIndex = this.turnOrder.indexOf(this.activeCombatant);
            this.activeCombatant = this.turnOrder[(currentIndex + 1) % this.turnOrder.length];
        }

        this.addToCombatHistory(`üîÑ –•–æ–¥ ${this.currentTurn}: ${this.getCombatantName(this.activeCombatant)}`);
        this.updateBattleInfo();

        if (this.activeCombatant.startsWith('bandit') || this.activeCombatant.startsWith('farmer')) {
            setTimeout(() => this.executeEnemyTurn(), 1000);
        }
    }

    executeEnemyTurn() {
        const enemy = this.combatants[this.activeCombatant];
        if (!enemy) return;

        const playerId = Object.keys(this.combatants).find(id => id.startsWith('player'));
        if (!playerId) return;

        const enemyPos = enemy.position;
        const playerPos = this.battlefield.getCharacterPosition(playerId);

        if (enemyPos && playerPos) {
            const distance = this.battlefield.calculateDistance(enemyPos.cellId, playerPos.cellId);
            
            if (distance <= 1) {
                this.performAttack(this.activeCombatant, playerId);
            } else {
                this.moveTowardsTarget(this.activeCombatant, playerPos.cellId);
            }
        }

        setTimeout(() => this.nextTurn(), 1000);
    }

    moveTowardsTarget(combatantId, targetCellId) {
        const combatant = this.combatants[combatantId];
        if (!combatant || !combatant.position) return false;

        const currentCellId = combatant.position.cellId;
        const neighbors = this.battlefield.getNeighbors(
            this.battlefield.getCellCoordinates(currentCellId).q,
            this.battlefield.getCellCoordinates(currentCellId).r
        );

        let bestCell = null;
        let bestDistance = Infinity;

        for (const neighborId of neighbors) {
            if (!this.battlefield.cells[neighborId].occupied) {
                const distance = this.battlefield.calculateDistance(neighborId, targetCellId);
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestCell = neighborId;
                }
            }
        }

        if (bestCell && this.battlefield.moveCharacter(combatantId, bestCell)) {
            combatant.position = this.battlefield.getCharacterPosition(combatantId);
            this.addToCombatHistory(`üö∂ ${this.getCombatantName(combatantId)} –ø–µ—Ä–µ–º–µ—Å—Ç–∏–ª—Å—è`);
            this.updateBattlefieldDisplay();
            return true;
        }

        return false;
    }

    performAttack(attackerId, targetId) {
        const attacker = this.combatants[attackerId];
        const target = this.combatants[targetId];
        
        if (!attacker || !target) return false;

        const attackerPos = attacker.position;
        const targetPos = this.battlefield.getCharacterPosition(targetId);
        
        if (!attackerPos || !targetPos) return false;

        const distance = this.battlefield.calculateDistance(attackerPos.cellId, targetPos.cellId);
        if (distance > 1) {
            this.addToCombatHistory(`‚ùå ${this.getCombatantName(attackerId)} –Ω–µ –º–æ–∂–µ—Ç –∞—Ç–∞–∫–æ–≤–∞—Ç—å - —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ`);
            return false;
        }

        const attackSkill = attacker.stats.skills['–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ'] || 10;
        const attackCheck = rollDice(20, 1);

        if (attackCheck.total >= 10) {
            const damage = this.calculateDamage(attacker);
            target.stats.health -= damage;

            this.addToCombatHistory(`üó°Ô∏è ${this.getCombatantName(attackerId)} –Ω–∞–Ω–æ—Å–∏—Ç ${damage} —É—Ä–æ–Ω–∞!`);

            if (target.stats.health <= 0) {
                target.stats.health = 0;
                this.addToCombatHistory(`üíÄ ${this.getCombatantName(targetId)} —É–±–∏—Ç!`);
                this.removeCombatant(targetId);
            }
        } else {
            this.addToCombatHistory(`‚ùå ${this.getCombatantName(attackerId)} –ø—Ä–æ–º–∞—Ö–∏–≤–∞–µ—Ç—Å—è!`);
        }

        this.updateBattleInfo();
        return true;
    }

    calculateDamage(attacker) {
        const baseDamage = rollDice(6, 1).total;
        const skillBonus = Math.floor((attacker.stats.skills['–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ'] || 10) / 5);
        return Math.max(1, baseDamage + skillBonus);
    }

    removeCombatant(combatantId) {
        this.battlefield.removeCharacter(combatantId);
        delete this.combatants[combatantId];
        this.checkCombatEnd();
    }

    checkCombatEnd() {
        const players = Object.keys(this.combatants).filter(id => id.startsWith('player'));
        const enemies = Object.keys(this.combatants).filter(id => !id.startsWith('player'));

        if (players.length === 0) {
            this.endCombat('defeat');
        } else if (enemies.length === 0) {
            this.endCombat('victory');
        }
    }

    endCombat(result) {
        this.isCombatActive = false;
        
        if (result === 'victory') {
            this.addToCombatHistory(`üéâ –ü–æ–±–µ–¥–∞! –í—Å–µ –≤—Ä–∞–≥–∏ –ø–æ–≤–µ—Ä–∂–µ–Ω—ã!`);
        } else {
            this.addToCombatHistory(`üíÄ –ü–æ—Ä–∞–∂–µ–Ω–∏–µ!`);
        }

        this.updateBattleInfo();
    }

    getCombatantName(combatantId) {
        if (combatantId.startsWith('player')) return '–ò–≥—Ä–æ–∫';
        if (combatantId.startsWith('farmer')) return '–§–µ—Ä–º–µ—Ä';
        if (combatantId.startsWith('bandit')) return '–†–∞–∑–±–æ–π–Ω–∏–∫';
        return combatantId;
    }

    addToCombatHistory(message) {
        this.combatHistory.unshift({
            turn: this.currentTurn,
            message: message,
            timestamp: new Date().toLocaleTimeString()
        });

        if (this.combatHistory.length > 20) {
            this.combatHistory.pop();
        }

        this.updateCombatHistoryDisplay();
    }

    updateCombatHistoryDisplay() {
        const historyElement = document.getElementById('combatHistory');
        if (!historyElement) return;

        let historyHTML = '<h4 style="color: #d4af37; margin-bottom: 10px;">üìú –ò—Å—Ç–æ—Ä–∏—è –±–æ—è:</h4>';
        
        this.combatHistory.slice(0, 10).forEach(entry => {
            historyHTML += `
                <div style="padding: 5px 0; border-bottom: 1px solid #3d2418; font-size: 0.9em;">
                    <span style="color: #8b7d6b;">[${entry.timestamp}]</span> ${entry.message}
                </div>
            `;
        });

        historyElement.innerHTML = historyHTML;
    }

    updateBattleInfo() {
        const battleStatus = document.getElementById('battleStatus');
        if (!battleStatus) return;

        let statusHTML = '';

        if (this.isCombatActive) {
            statusHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                    <div><strong>–¢–µ–∫—É—â–∏–π —Ö–æ–¥:</strong> ${this.currentTurn}</div>
                    <div><strong>–ê–∫—Ç–∏–≤–Ω—ã–π:</strong> ${this.getCombatantName(this.activeCombatant)}</div>
                </div>
                <div><strong>–°—Ç–∞—Ç—É—Å:</strong> –ë–æ–π –∞–∫—Ç–∏–≤–µ–Ω</div>
            `;
        } else {
            statusHTML = `<strong>–°—Ç–∞—Ç—É—Å:</strong> –ë–æ–π –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω`;
        }

        statusHTML += `<div style="margin-top: 15px;"><strong>–£—á–∞—Å—Ç–Ω–∏–∫–∏:</strong></div>`;
        
        for (const combatantId in this.combatants) {
            const combatant = this.combatants[combatantId];
            const healthPercent = (combatant.stats.health / combatant.stats.maxHealth) * 100;
            const healthColor = healthPercent > 60 ? '#27ae60' : healthPercent > 30 ? '#f39c12' : '#e74c3c';
            
            statusHTML += `
                <div style="display: flex; justify-content: space-between; align-items: center; 
                     padding: 5px 0; border-bottom: 1px solid #3d2418;">
                    <span>${this.getCombatantName(combatantId)}</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div style="width: 60px; height: 8px; background: #2c1810; border-radius: 4px;">
                            <div style="width: ${healthPercent}%; height: 100%; background: ${healthColor}; border-radius: 4px;"></div>
                        </div>
                        <span style="font-size: 0.9em;">${combatant.stats.health}/${combatant.stats.maxHealth}</span>
                    </div>
                </div>
            `;
        }

        battleStatus.innerHTML = statusHTML;
    }
}

// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========

let battlefield = null;
let battlefieldRenderer = null;
let combatSystem = null;

// ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========

function initializeCombatSystem() {
    const combatTab = document.getElementById('combat-tab');
    if (!combatTab) return;

    combatTab.innerHTML = `
        <div style="margin-bottom: 20px;">
            <h2 class="section-title">‚öîÔ∏è –ë–æ–µ–≤–∞—è –°–∏—Å—Ç–µ–º–∞</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div>
                    <h3 style="color: #d4af37; margin-bottom: 10px;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—è</h3>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #e0d0c0;">–õ–∞–Ω–¥—à–∞—Ñ—Ç:</label>
                        <select id="landscapeSelect" style="width: 100%; padding: 10px; border: 2px solid #8b4513; 
                              border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                            <option value="forest">üå≤ –õ–µ—Å</option>
                            <option value="city">üèôÔ∏è –ì–æ—Ä–æ–¥</option>
                            <option value="plains">üåæ –†–∞–≤–Ω–∏–Ω—ã</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; color: #e0d0c0;">–†–∞–∑–º–µ—Ä –ø–æ–ª—è:</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="number" id="battlefieldWidth" value="12" min="5" max="20" 
                                   style="flex: 1; padding: 10px; border: 2px solid #8b4513; border-radius: 4px; 
                                   background: #1a0f0b; color: #e0d0c0;">
                            <span style="color: #e0d0c0; line-height: 40px;">√ó</span>
                            <input type="number" id="battlefieldHeight" value="8" min="5" max="15" 
                                   style="flex: 1; padding: 10px; border: 2px solid #8b4513; border-radius: 4px; 
                                   background: #1a0f0b; color: #e0d0c0;">
                        </div>
                    </div>
                    
                    <button class="btn btn-plus" onclick="createBattlefield()" style="width: 100%; margin-bottom: 10px;">
                        üé≤ –°–æ–∑–¥–∞—Ç—å –ø–æ–ª–µ –±–æ—è
                    </button>
                    
                    <button class="btn btn-roll" onclick="startCombat()" style="width: 100%;">
                        ‚öîÔ∏è –ù–∞—á–∞—Ç—å –±–æ–π
                    </button>
                </div>
                
                <div>
                    <h3 style="color: #d4af37; margin-bottom: 10px;">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <button class="btn btn-roll" onclick="addPlayerToBattlefield()">‚ûï –ò–≥—Ä–æ–∫</button>
                        <button class="btn btn-roll" onclick="addBanditToBattlefield()">üíÄ –†–∞–∑–±–æ–π–Ω–∏–∫</button>
                        <button class="btn btn-roll" onclick="addFarmerToBattlefield()">üë®‚Äçüåæ –§–µ—Ä–º–µ—Ä</button>
                        <button class="btn btn-minus" onclick="clearBattlefield()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å</button>
                    </div>
                    
                    <div style="background: #3d2418; padding: 15px; border-radius: 6px;">
                        <h4 style="color: #d4af37; margin-bottom: 10px;">–õ–µ–≥–µ–Ω–¥–∞:</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.9em;">
                            <div>üë§ - –ò–≥—Ä–æ–∫</div>
                            <div>üíÄ - –†–∞–∑–±–æ–π–Ω–∏–∫</div>
                            <div>üë®‚Äçüåæ - –§–µ—Ä–º–µ—Ä</div>
                            <div>üå≤ - –î–µ—Ä–µ–≤–æ</div>
                            <div>ü™® - –ö–∞–º–µ–Ω—å</div>
                            <div>üè† - –ó–¥–∞–Ω–∏–µ</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="battlefieldContainer" style="min-height: 500px; background: #1a0f0b; 
                 border: 2px solid #5a3928; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <p style="text-align: center; color: #8b7d6b; padding: 50px;">
                    –°–æ–∑–¥–∞–π—Ç–µ –ø–æ–ª–µ –±–æ—è —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å
                </p>
            </div>
            
            <div id="battleInfo" style="background: #3d2418; padding: 15px; border-radius: 6px; display: none;">
                <h3 style="color: #d4af37; margin-bottom: 10px;">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –±–æ–µ</h3>
                <div id="battleStatus">–°—Ç–∞—Ç—É—Å: –û–∂–∏–¥–∞–Ω–∏–µ –Ω–∞—á–∞–ª–∞</div>
            </div>

            <div id="combatControls" style="display: none;">
                <!-- –ë–æ–µ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–ª—è—Ç—å—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ -->
            </div>
        </div>
    `;
}

function createBattlefield() {
    const width = parseInt(document.getElementById('battlefieldWidth').value) || 12;
    const height = parseInt(document.getElementById('battlefieldHeight').value) || 8;
    const landscapeType = document.getElementById('landscapeSelect').value;

    battlefield = new HexagonalBattlefield(width, height);
    battlefieldRenderer = new BattlefieldRenderer(battlefield, 'battlefieldContainer');
    
    generateLandscape(battlefield, landscapeType);
    battlefieldRenderer.render();
    
    document.getElementById('battleInfo').style.display = 'block';
    
    console.log(`‚úÖ –ü–æ–ª–µ –±–æ—è —Å–æ–∑–¥–∞–Ω–æ: ${width}x${height}, –ª–∞–Ω–¥—à–∞—Ñ—Ç: ${landscapeType}`);
}

function addPlayerToBattlefield() {
    if (!battlefield) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø–æ–ª–µ –±–æ—è!');
        return;
    }

    const startCell = battlefield.getCellId(1, battlefield.height - 2);
    if (battlefield.placeCharacter('player_1', startCell)) {
        battlefieldRenderer.render();
        console.log('‚úÖ –ò–≥—Ä–æ–∫ –¥–æ–±–∞–≤–ª–µ–Ω –Ω–∞ –ø–æ–ª–µ –±–æ—è');
    }
}

function addBanditToBattlefield() {
    if (!battlefield) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø–æ–ª–µ –±–æ—è!');
        return;
    }

    const banditId = 'bandit_' + Date.now();
    const randomQ = Math.floor(Math.random() * (battlefield.width - 4)) + 2;
    const randomR = Math.floor(Math.random() * (battlefield.height - 4)) + 2;
    const startCell = battlefield.getCellId(randomQ, randomR);
    
    if (battlefield.placeCharacter(banditId, startCell)) {
        battlefieldRenderer.render();
        console.log('‚úÖ –†–∞–∑–±–æ–π–Ω–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω –Ω–∞ –ø–æ–ª–µ –±–æ—è');
    }
}

function addFarmerToBattlefield() {
    if (!battlefield) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø–æ–ª–µ –±–æ—è!');
        return;
    }

    const farmerId = 'farmer_' + Date.now();
    const startCell = battlefield.getCellId(battlefield.width - 2, 1);
    if (battlefield.placeCharacter(farmerId, startCell)) {
        battlefieldRenderer.render();
        console.log('‚úÖ –§–µ—Ä–º–µ—Ä –¥–æ–±–∞–≤–ª–µ–Ω –Ω–∞ –ø–æ–ª–µ –±–æ—è');
    }
}

function clearBattlefield() {
    if (!battlefield) return;
    
    for (const characterId in battlefield.characters) {
        battlefield.removeCharacter(characterId);
    }
    
    battlefieldRenderer.render();
    console.log('‚úÖ –ü–æ–ª–µ –±–æ—è –æ—á–∏—â–µ–Ω–æ');
}

function startCombat() {
    if (!battlefield) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø–æ–ª–µ –±–æ—è –∏ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π!');
        return;
    }

    combatSystem = new CombatSystem(battlefield);

    for (const characterId in battlefield.characters) {
        let type = 'player';
        let stats = { health: 100, maxHealth: 100 };

        if (characterId.startsWith('bandit')) {
            type = 'bandit';
            stats = {
                health: 80,
                maxHealth: 80,
                skills: { '–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ': 12 }
            };
        } else if (characterId.startsWith('farmer')) {
            type = 'farmer';
            stats = {
                health: 60,
                maxHealth: 60,
                skills: { '–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ': 8 }
            };
        } else if (characterId.startsWith('player')) {
            if (window.currentCharacter) {
                stats = {
                    health: currentCharacter.stats.health,
                    maxHealth: currentCharacter.stats.maxHealth,
                    skills: currentCharacter.skills
                };
            }
        }

        combatSystem.addCombatant(characterId, type, stats);
    }

    combatSystem.startCombat();
    updateCombatInterface();

    const combatTab = document.getElementById('combat-tab');
    const existingControls = document.getElementById('combatControls');
    if (!existingControls) {
        const controlsHTML = `
            <div id="combatControls" style="background: #3d2418; padding: 20px; border-radius: 8px; 
                 border: 2px solid #8b4513; margin-top: 20px;">
            </div>
        `;
        combatTab.insertAdjacentHTML('beforeend', controlsHTML);
    }

    updateCombatInterface();
}

function updateCombatInterface() {
    const combatControls = document.getElementById('combatControls');
    if (!combatControls) return;

    const isPlayerTurn = combatSystem && combatSystem.activeCombatant && 
                        combatSystem.activeCombatant.startsWith('player');

    combatControls.style.display = 'block';
    combatControls.innerHTML = `
        <h3 style="color: #d4af37; margin-bottom: 15px;">–î–µ–π—Å—Ç–≤–∏—è –≤ –±–æ—é</h3>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
            <button class="btn btn-roll" onclick="playerAttack()" ${!isPlayerTurn ? 'disabled' : ''}>
                ‚öîÔ∏è –ê—Ç–∞–∫–∞
            </button>
            <button class="btn btn-roll" onclick="playerEndTurn()" ${!isPlayerTurn ? 'disabled' : ''}>
                ‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ö–æ–¥
            </button>
        </div>
        
        <button class="btn btn-minus" onclick="endCombat()" style="width: 100%;">
            üè≥Ô∏è –ó–∞–≤–µ—Ä—à–∏—Ç—å –±–æ–π
        </button>
        
        <div id="combatHistory" style="margin-top: 20px; max-height: 200px; overflow-y: auto; 
             background: #2c1810; padding: 10px; border-radius: 6px; border: 1px solid #5a3928;">
        </div>
    `;

    if (combatSystem) {
        combatSystem.updateCombatHistoryDisplay();
    }
}

function playerAttack() {
    if (!combatSystem || !combatSystem.activeCombatant) return;

    const enemies = Object.keys(combatSystem.combatants).filter(id => 
        !id.startsWith('player') && combatSystem.combatants[id].stats.health > 0
    );

    if (enemies.length === 0) {
        alert('–ù–µ—Ç –≤—Ä–∞–≥–æ–≤ –¥–ª—è –∞—Ç–∞–∫–∏!');
        return;
    }

    const attackerId = combatSystem.activeCombatant;
    let closestEnemy = null;
    let closestDistance = Infinity;

    for (const enemyId of enemies) {
        const attackerPos = combatSystem.combatants[attackerId].position;
        const enemyPos = combatSystem.battlefield.getCharacterPosition(enemyId);
        if (attackerPos && enemyPos) {
            const distance = combatSystem.battlefield.calculateDistance(
                attackerPos.cellId, enemyPos.cellId
            );
            if (distance < closestDistance) {
                closestDistance = distance;
                closestEnemy = enemyId;
            }
        }
    }

    if (closestEnemy && closestDistance <= 1) {
        combatSystem.performAttack(attackerId, closestEnemy);
        updateCombatInterface();
    } else {
        alert('–ù–µ—Ç –≤—Ä–∞–≥–æ–≤ –≤ —Ä–∞–¥–∏—É—Å–µ –∞—Ç–∞–∫–∏!');
    }
}

function playerEndTurn() {
    if (!combatSystem) return;
    combatSystem.nextTurn();
    updateCombatInterface();
}

function endCombat() {
    if (combatSystem) {
        combatSystem.endCombat('manual');
        combatSystem = null;
    }
    updateCombatInterface();
}

function updateBattlefieldDisplay() {
    if (battlefieldRenderer) {
        battlefieldRenderer.render();
    }
}

// ========== –°–ò–°–¢–ï–ú–ê –ö–£–ë–ò–ö–û–í ==========

function rollDice(sides, count = 1) {
    let results = [];
    let total = 0;
    
    for (let i = 0; i < count; i++) {
        const result = Math.floor(Math.random() * sides) + 1;
        results.push(result);
        total += result;
    }
    
    return { results, total };
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

console.log('‚úÖ combat.js –∑–∞–≥—Ä—É–∂–µ–Ω! –ë–æ–µ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞.');
        // inventory.js - –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è D&D

// ========== –ö–û–ù–°–¢–ê–ù–¢–´ –ü–†–ï–î–ú–ï–¢–û–í ==========

const itemTemplates = {
    // –û—Ä—É–∂–∏–µ –±–ª–∏–∂–Ω–µ–≥–æ –±–æ—è
    weapons: {
        dagger: {
            id: 'dagger',
            name: '–ö–∏–Ω–∂–∞–ª',
            type: 'weapon',
            subtype: 'one_handed',
            damageType: 'piercing',
            damage: '1d4',
            hands: 1,
            weight: 0.5,
            value: 10,
            description: '–ù–µ–±–æ–ª—å—à–æ–π —Å–∫—Ä—ã—Ç—ã–π –∫–ª–∏–Ω–æ–∫'
        },
        shortsword: {
            id: 'shortsword',
            name: '–ö–æ—Ä–æ—Ç–∫–∏–π –º–µ—á',
            type: 'weapon', 
            subtype: 'one_handed',
            damageType: 'slashing',
            damage: '1d6',
            hands: 1,
            weight: 2,
            value: 25,
            description: '–°–±–∞–ª–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–¥–Ω–æ—Ä—É—á–Ω—ã–π –º–µ—á'
        },
        longsword: {
            id: 'longsword',
            name: '–î–ª–∏–Ω–Ω—ã–π –º–µ—á',
            type: 'weapon',
            subtype: 'one_handed',
            damageType: 'slashing',
            damage: '1d8',
            hands: 1,
            weight: 3,
            value: 40,
            description: '–ù–∞–¥–µ–∂–Ω—ã–π –±–æ–µ–≤–æ–π –º–µ—á'
        },
        axe: {
            id: 'axe',
            name: '–¢–æ–ø–æ—Ä',
            type: 'weapon',
            subtype: 'one_handed', 
            damageType: 'slashing',
            damage: '1d8',
            hands: 1,
            weight: 3,
            value: 30,
            description: '–¢—è–∂–µ–ª—ã–π –±–æ–µ–≤–æ–π —Ç–æ–ø–æ—Ä'
        },
        greatsword: {
            id: 'greatsword',
            name: '–î–≤—É—Ä—É—á–Ω—ã–π –º–µ—á',
            type: 'weapon',
            subtype: 'two_handed',
            damageType: 'slashing', 
            damage: '2d6',
            hands: 2,
            weight: 5,
            value: 50,
            description: '–ú–æ—â–Ω–æ–µ –¥–≤—É—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ'
        },
        spear: {
            id: 'spear',
            name: '–ö–æ–ø—å–µ',
            type: 'weapon',
            subtype: 'polearm',
            damageType: 'piercing',
            damage: '1d8',
            hands: 2,
            weight: 3,
            value: 15,
            description: '–î—Ä–µ–≤–∫–æ–≤–æ–µ –æ—Ä—É–∂–∏–µ —Å –¥–ª–∏–Ω–Ω–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–µ–π'
        }
    },

    // –©–∏—Ç—ã
    shields: {
        buckler: {
            id: 'buckler',
            name: '–ë–∞–∫–ª–µ—Ä',
            type: 'shield',
            armorBonus: 1,
            weight: 2,
            value: 15,
            description: '–ù–µ–±–æ–ª—å—à–æ–π –∫—Ä—É–≥–ª—ã–π —â–∏—Ç'
        },
        round_shield: {
            id: 'round_shield',
            name: '–ö—Ä—É–≥–ª—ã–π —â–∏—Ç',
            type: 'shield', 
            armorBonus: 2,
            weight: 4,
            value: 30,
            description: '–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –¥–µ—Ä–µ–≤—è–Ω–Ω—ã–π —â–∏—Ç'
        },
        tower_shield: {
            id: 'tower_shield',
            name: '–ë–∞—à–µ–Ω–Ω—ã–π —â–∏—Ç',
            type: 'shield',
            armorBonus: 3,
            weight: 8,
            value: 50,
            description: '–ë–æ–ª—å—à–æ–π —â–∏—Ç, –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—â–∏–π –æ—Ç–ª–∏—á–Ω—É—é –∑–∞—â–∏—Ç—É'
        }
    },

    // –ë—Ä–æ–Ω—è
    armor: {
        leather_armor: {
            id: 'leather_armor',
            name: '–ö–æ–∂–∞–Ω–∞—è –±—Ä–æ–Ω—è',
            type: 'armor',
            armorClass: 2,
            weight: 5,
            value: 20,
            description: '–ü—Ä–æ—Å—Ç–∞—è –∫–æ–∂–∞–Ω–∞—è –∑–∞—â–∏—Ç–∞'
        },
        chainmail: {
            id: 'chainmail', 
            name: '–ö–æ–ª—å—á—É–≥–∞',
            type: 'armor',
            armorClass: 4,
            weight: 12,
            value: 75,
            description: '–ú–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∞—è –∫–æ–ª—å—á—É–∂–Ω–∞—è —Ä—É–±–∞—Ö–∞'
        },
        plate_armor: {
            id: 'plate_armor',
            name: '–õ–∞—Ç–Ω–∞—è –±—Ä–æ–Ω—è',
            type: 'armor',
            armorClass: 6, 
            weight: 20,
            value: 200,
            description: '–ü–æ–ª–Ω—ã–π –∫–æ–º–ø–ª–µ–∫—Ç –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏—Ö –¥–æ—Å–ø–µ—Ö–æ–≤'
        }
    },

    // –ò—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞
    light_sources: {
        torch: {
            id: 'torch',
            name: '–§–∞–∫–µ–ª',
            type: 'light_source',
            lightRadius: 10,
            duration: 60,
            weight: 1,
            value: 1,
            description: '–ü—Ä–æ—Å—Ç–æ–π –∏—Å—Ç–æ—á–Ω–∏–∫ —Å–≤–µ—Ç–∞'
        },
        lantern: {
            id: 'lantern',
            name: '–§–æ–Ω–∞—Ä—å',
            type: 'light_source',
            lightRadius: 15,
            duration: 120,
            weight: 2,
            value: 10,
            description: '–ú–∞—Å–ª—è–Ω—ã–π —Ñ–æ–Ω–∞—Ä—å —Å —Ä–µ–≥—É–ª–∏—Ä—É–µ–º—ã–º —Å–≤–µ—Ç–æ–º'
        }
    },

    // –ë–æ–µ–ø—Ä–∏–ø–∞—Å—ã
    ammunition: {
        arrows: {
            id: 'arrows',
            name: '–°—Ç—Ä–µ–ª—ã',
            type: 'ammunition',
            subtype: 'arrows',
            quantity: 20,
            weight: 0.5,
            value: 5,
            description: '–ö–æ–ª—á–∞–Ω —Å–æ —Å—Ç—Ä–µ–ª–∞–º–∏'
        },
        bolts: {
            id: 'bolts',
            name: '–ë–æ–ª—Ç—ã',
            type: 'ammunition', 
            subtype: 'bolts',
            quantity: 20,
            weight: 0.5,
            value: 5,
            description: '–ù–∞–±–æ—Ä –±–æ–ª—Ç–æ–≤ –¥–ª—è –∞—Ä–±–∞–ª–µ—Ç–∞'
        }
    },

    // –ó–µ–ª—å—è
    potions: {
        healing_potion: {
            id: 'healing_potion',
            name: '–ó–µ–ª—å–µ –ª–µ—á–µ–Ω–∏—è',
            type: 'potion',
            effect: 'heal',
            power: '2d4+2',
            weight: 0.5,
            value: 50,
            description: '–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –ø—Ä–∏ —É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–∏'
        },
        mana_potion: {
            id: 'mana_potion',
            name: '–ó–µ–ª—å–µ –º–∞–Ω—ã',
            type: 'potion',
            effect: 'restore_mana',
            power: '2d4+2',
            weight: 0.5,
            value: 75,
            description: '–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –º–∞–Ω—É'
        },
        stamina_potion: {
            id: 'stamina_potion',
            name: '–ó–µ–ª—å–µ –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç–∏',
            type: 'potion',
            effect: 'restore_stamina',
            power: '2d4+2',
            weight: 0.5,
            value: 40,
            description: '–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å'
        }
    },

    // –ü—Ä–æ—á–µ–µ —Å–Ω–∞—Ä—è–∂–µ–Ω–∏–µ
    misc: {
        rope: {
            id: 'rope',
            name: '–í–µ—Ä–µ–≤–∫–∞',
            type: 'tool',
            length: 15,
            weight: 2,
            value: 1,
            description: '–ü—Ä–æ—á–Ω–∞—è –ø–µ–Ω—å–∫–æ–≤–∞—è –≤–µ—Ä–µ–≤–∫–∞'
        },
        lockpicks: {
            id: 'lockpicks',
            name: '–û—Ç–º—ã—á–∫–∏',
            type: 'tool',
            quality: 'basic',
            weight: 0.5,
            value: 25,
            description: '–ù–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –≤–∑–ª–æ–º–∞'
        },
        bedroll: {
            id: 'bedroll',
            name: '–°–ø–∞–ª—å–Ω—ã–π –º–µ—à–æ–∫',
            type: 'camping',
            weight: 3,
            value: 5,
            description: '–ö–æ–º–ø–∞–∫—Ç–Ω—ã–π —Å–ø–∞–ª—å–Ω—ã–π –º–µ—à–æ–∫'
        },
        rations: {
            id: 'rations',
            name: '–°—É—Ö–æ–π –ø–∞–µ–∫',
            type: 'food',
            quantity: 5,
            weight: 1,
            value: 2,
            description: '–ù–µ–ø—Ä–∏—Ö–æ—Ç–ª–∏–≤–∞—è –ø–æ—Ö–æ–¥–Ω–∞—è –µ–¥–∞'
        }
    }
};

// ========== –ö–õ–ê–°–° –ò–ù–í–ï–ù–¢–ê–†–Ø ==========

class InventorySystem {
    constructor(character) {
        this.character = character;
        this.items = [];
        this.equipped = {
            weapon: null,
            shield: null,
            armor: null,
            light_source: null
        };
        this.carryCapacity = this.calculateCarryCapacity();
        this.loadInventory();
    }

    calculateCarryCapacity() {
        const strength = this.character.getSkillValue('–í—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç—å') || 10;
        return Math.max(20, strength * 2);
    }

    getCurrentWeight() {
        return this.items.reduce((total, item) => {
            return total + (item.weight * (item.quantity || 1));
        }, 0);
    }

    getEncumbranceLevel() {
        const weight = this.getCurrentWeight();
        const capacity = this.carryCapacity;
        const ratio = weight / capacity;

        if (ratio < 0.3) return 'none';
        if (ratio < 0.6) return 'light';
        if (ratio < 0.9) return 'medium';
        return 'heavy';
    }

    getEncumbranceModifiers() {
        const level = this.getEncumbranceLevel();
        const modifiers = {
            none: { movement: 0, stealth: 0, agility: 0 },
            light: { movement: -1, stealth: -1, agility: -1 },
            medium: { movement: -2, stealth: -2, agility: -2 },
            heavy: { movement: -5, stealth: -5, agility: -5 }
        };
        return modifiers[level];
    }

    addItem(itemTemplate, quantity = 1) {
        const existingItem = this.items.find(item => item.id === itemTemplate.id);
        
        if (existingItem && this.isStackable(itemTemplate)) {
            existingItem.quantity += quantity;
        } else {
            const newItem = {
                ...itemTemplate,
                quantity: quantity,
                equipped: false
            };
            this.items.push(newItem);
        }

        this.saveInventory();
        return true;
    }

    removeItem(itemId, quantity = 1) {
        const itemIndex = this.items.findIndex(item => item.id === itemId);
        if (itemIndex === -1) return false;

        const item = this.items[itemIndex];
        
        if (item.quantity > quantity) {
            item.quantity -= quantity;
        } else {
            if (item.equipped) {
                this.unequipItem(itemId);
            }
            this.items.splice(itemIndex, 1);
        }

        this.saveInventory();
        return true;
    }

    isStackable(item) {
        return item.type !== 'weapon' && item.type !== 'armor' && item.type !== 'shield';
    }

    equipItem(itemId) {
        const item = this.items.find(i => i.id === itemId);
        if (!item) return false;

        if (!this.canEquipItem(item)) {
            return false;
        }

        if (item.type === 'weapon') {
            if (this.equipped.weapon) {
                this.unequipItem(this.equipped.weapon.id);
            }
            this.equipped.weapon = item;
        } else if (item.type === 'shield') {
            if (this.equipped.shield) {
                this.unequipItem(this.equipped.shield.id);
            }
            this.equipped.shield = item;
        } else if (item.type === 'armor') {
            if (this.equipped.armor) {
                this.unequipItem(this.equipped.armor.id);
            }
            this.equipped.armor = item;
        } else if (item.type === 'light_source') {
            if (this.equipped.light_source) {
                this.unequipItem(this.equipped.light_source.id);
            }
            this.equipped.light_source = item;
        }

        item.equipped = true;
        this.saveInventory();
        return true;
    }

    unequipItem(itemId) {
        const item = this.items.find(i => i.id === itemId);
        if (!item || !item.equipped) return false;

        if (this.equipped.weapon === item) this.equipped.weapon = null;
        if (this.equipped.shield === item) this.equipped.shield = null;
        if (this.equipped.armor === item) this.equipped.armor = null;
        if (this.equipped.light_source === item) this.equipped.light_source = null;

        item.equipped = false;
        this.saveInventory();
        return true;
    }

    canEquipItem(item) {
        if (item.type === 'weapon' && item.hands === 2 && this.equipped.shield) {
            return false;
        }

        if (item.type === 'weapon') {
            const requiredSkill = this.getWeaponSkill(item);
            const skillValue = this.character.getSkillValue(requiredSkill) || 5;
            if (skillValue < 5) {
                return false;
            }
        }

        return true;
    }

    getWeaponSkill(weapon) {
        const skillMap = {
            'one_handed': '–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ',
            'two_handed': '–î–≤—É—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ',
            'polearm': '–î—Ä–µ–≤–∫–æ–≤–æ–µ',
            'ranged': '–°—Ç—Ä–µ–ª—å–±–∞',
            'thrown': '–ú–µ—Ç–∞–Ω–∏–µ'
        };
        return skillMap[weapon.subtype] || '–û–¥–Ω–æ—Ä—É—á–Ω–æ–µ –æ—Ä—É–∂–∏–µ';
    }

    getCombatModifiers() {
        const modifiers = {
            attack: 0,
            damage: 0,
            armorClass: 0,
            movement: 0
        };

        if (this.equipped.weapon) {
            const weaponSkill = this.getWeaponSkill(this.equipped.weapon);
            const skillValue = this.character.getSkillValue(weaponSkill) || 5;
            modifiers.attack += Math.floor((skillValue - 5) / 2);
        }

        if (this.equipped.shield) {
            modifiers.armorClass += this.equipped.shield.armorBonus;
        }

        if (this.equipped.armor) {
            modifiers.armorClass += this.equipped.armor.armorClass;
        }

        const encumbranceMods = this.getEncumbranceModifiers();
        modifiers.movement += encumbranceMods.movement;

        return modifiers;
    }

    useItem(itemId) {
        const item = this.items.find(i => i.id === itemId);
        if (!item) return false;

        switch (item.type) {
            case 'potion':
                return this.usePotion(item);
            case 'ammunition':
                return this.useAmmunition(item);
            case 'food':
                return this.useFood(item);
            default:
                return false;
        }
    }

    usePotion(potion) {
        let effect = '';
        let amount = 0;
        
        switch (potion.effect) {
            case 'heal':
                amount = this.rollDiceExpression(potion.power);
                this.character.stats.health = Math.min(
                    this.character.stats.health + amount,
                    this.character.stats.maxHealth
                );
                effect = `–≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç ${amount} –∑–¥–æ—Ä–æ–≤—å—è`;
                break;
            case 'restore_mana':
                amount = this.rollDiceExpression(potion.power);
                this.character.stats.mana = Math.min(
                    this.character.stats.mana + amount,
                    this.character.stats.maxMana
                );
                effect = `–≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç ${amount} –º–∞–Ω—ã`;
                break;
            case 'restore_stamina':
                amount = this.rollDiceExpression(potion.power);
                this.character.stats.stamina = Math.min(
                    this.character.stats.stamina + amount,
                    this.character.stats.maxStamina
                );
                effect = `–≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç ${amount} –≤—ã–Ω–æ—Å–ª–∏–≤–æ—Å—Ç–∏`;
                break;
        }

        this.removeItem(potion.id, 1);
        this.saveInventory();
        return { effect, amount };
    }

    useAmmunition(ammo) {
        if (ammo.quantity <= 0) return false;
        ammo.quantity--;
        if (ammo.quantity <= 0) {
            this.removeItem(ammo.id);
        }
        this.saveInventory();
        return true;
    }

    useFood(food) {
        if (food.quantity <= 0) return false;
        food.quantity--;
        if (food.quantity <= 0) {
            this.removeItem(food.id);
        }
        this.saveInventory();
        return true;
    }

    rollDiceExpression(expression) {
        const match = expression.match(/(\d+)d(\d+)([+-]\d+)?/);
        if (!match) return 0;

        const count = parseInt(match[1]);
        const sides = parseInt(match[2]);
        const modifier = match[3] ? parseInt(match[3]) : 0;

        let total = 0;
        for (let i = 0; i < count; i++) {
            total += Math.floor(Math.random() * sides) + 1;
        }
        return total + modifier;
    }

    saveInventory() {
        const inventoryData = {
            items: this.items,
            equipped: this.equipped
        };
        StorageSystem.set(`inventory_${this.character.id}`, inventoryData);
    }

    loadInventory() {
        const inventoryData = StorageSystem.get(`inventory_${this.character.id}`, {
            items: [],
            equipped: {
                weapon: null,
                shield: null,
                armor: null,
                light_source: null
            }
        });

        this.items = inventoryData.items;
        this.equipped = inventoryData.equipped;
    }

    getItemCount() {
        return this.items.reduce((total, item) => total + (item.quantity || 1), 0);
    }

    getTotalValue() {
        return this.items.reduce((total, item) => {
            return total + (item.value * (item.quantity || 1));
        }, 0);
    }
}

// ========== –ò–ù–¢–ï–†–§–ï–ô–° –ò–ù–í–ï–ù–¢–ê–†–Ø ==========

function initializeInventoryInterface() {
    const inventoryTab = document.getElementById('inventory-tab');
    if (!inventoryTab || !currentCharacter) return;

    const inventorySystem = new InventorySystem(currentCharacter);

    inventoryTab.innerHTML = `
        <div style="margin-bottom: 20px;">
            <h2 class="section-title">üéí –°–∏—Å—Ç–µ–º–∞ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—è</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div>
                    <h3 style="color: #d4af37; margin-bottom: 15px;">üìä –°—Ç–∞—Ç—É—Å —Å–Ω–∞—Ä—è–∂–µ–Ω–∏—è</h3>
                    
                    <div style="background: #3d2418; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>–í–µ—Å:</span>
                            <span>${inventorySystem.getCurrentWeight().toFixed(1)} / ${inventorySystem.carryCapacity} –∫–≥</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                            <span>–ó–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å:</span>
                            <span style="color: ${getEncumbranceColor(inventorySystem.getEncumbranceLevel())}">
                                ${getEncumbranceText(inventorySystem.getEncumbranceLevel())}
                            </span>
                        </div>
                        <div style="background: #2c1810; height: 10px; border-radius: 5px; overflow: hidden;">
                            <div style="height: 100%; background: #27ae60; width: ${(inventorySystem.getCurrentWeight() / inventorySystem.carryCapacity) * 100}%;"></div>
                        </div>
                    </div>

                    <div style="background: #3d2418; padding: 15px; border-radius: 6px;">
                        <h4 style="color: #d4af37; margin-bottom: 10px;">üéØ –≠–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–æ</h4>
                        <div id="equippedItems">
                            ${renderEquippedItems(inventorySystem)}
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 style="color: #d4af37; margin-bottom: 15px;">üõí –î–æ–±–∞–≤–∏—Ç—å –ø—Ä–µ–¥–º–µ—Ç—ã</h3>
                    
                    <div style="background: #3d2418; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <select id="itemCategory" style="width: 100%; padding: 10px; margin-bottom: 10px; 
                              border: 2px solid #8b4513; border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                            <option value="weapons">‚öîÔ∏è –û—Ä—É–∂–∏–µ</option>
                            <option value="shields">üõ°Ô∏è –©–∏—Ç—ã</option>
                            <option value="armor">ü•ã –ë—Ä–æ–Ω—è</option>
                            <option value="light_sources">üí° –ò—Å—Ç–æ—á–Ω–∏–∫–∏ —Å–≤–µ—Ç–∞</option>
                            <option value="ammunition">üèπ –ë–æ–µ–ø—Ä–∏–ø–∞—Å—ã</option>
                            <option value="potions">üß™ –ó–µ–ª—å—è</option>
                            <option value="misc">üéí –ü—Ä–æ—á–µ–µ</option>
                        </select>
                        
                        <select id="itemSelect" style="width: 100%; padding: 10px; margin-bottom: 10px; 
                              border: 2px solid #8b4513; border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                            ${renderItemOptions('weapons')}
                        </select>
                        
                        <div style="display: flex; gap: 10px;">
                            <input type="number" id="itemQuantity" value="1" min="1" 
                                   style="flex: 1; padding: 10px; border: 2px solid #8b4513; border-radius: 4px; 
                                   background: #1a0f0b; color: #e0d0c0;">
                            <button class="btn btn-plus" onclick="addItemToInventory()">–î–æ–±–∞–≤–∏—Ç—å</button>
                        </div>
                    </div>
                    
                    <button class="btn btn-roll" onclick="showQuickEquipment()" style="width: 100%; margin-bottom: 10px;">
                        üéÅ –ë—ã—Å—Ç—Ä–∞—è —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∞
                    </button>
                    
                    <button class="btn btn-roll" onclick="clearInventory()" style="width: 100%;">
                        üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å
                    </button>
                </div>
            </div>
            
            <div style="background: #3d2418; padding: 20px; border-radius: 8px; border: 2px solid #5a3928;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="color: #d4af37; margin: 0;">üéí –°–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è</h3>
                    <div style="color: #8b7d6b;">
                        –ü—Ä–µ–¥–º–µ—Ç–æ–≤: ${inventorySystem.getItemCount()} | 
                        –°—Ç–æ–∏–º–æ—Å—Ç—å: ${inventorySystem.getTotalValue()} –∑–æ–ª.
                    </div>
                </div>
                
                <input type="text" id="inventorySearch" placeholder="üîç –ü–æ–∏—Å–∫ –ø—Ä–µ–¥–º–µ—Ç–æ–≤..." 
                       style="width: 100%; padding: 10px; margin-bottom: 15px; border: 2px solid #8b4513; 
                       border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                
                <div id="inventoryItems">
                    ${renderInventoryItems(inventorySystem)}
                </div>
            </div>
        </div>
    `;

    document.getElementById('itemCategory').addEventListener('change', function() {
        updateItemOptions(this.value);
    });
    
    document.getElementById('inventorySearch').addEventListener('input', function() {
        filterInventoryItems(this.value);
    });
}

function renderEquippedItems(inventorySystem) {
    let html = '';
    
    const slots = [
        { key: 'weapon', label: '–û—Ä—É–∂–∏–µ', icon: '‚öîÔ∏è' },
        { key: 'shield', label: '–©–∏—Ç', icon: 'üõ°Ô∏è' },
        { key: 'armor', label: '–ë—Ä–æ–Ω—è', icon: 'ü•ã' },
        { key: 'light_source', label: '–°–≤–µ—Ç', icon: 'üí°' }
    ];

    slots.forEach(slot => {
        const item = inventorySystem.equipped[slot.key];
        html += `
            <div style="display: flex; justify-content: space-between; align-items: center; 
                 padding: 8px 0; border-bottom: 1px solid #5a3928;">
                <div>
                    <span style="margin-right: 10px;">${slot.icon}</span>
                    <span>${slot.label}:</span>
                </div>
                <div>
                    ${item ? `
                        <span>${item.name}</span>
                        <button class="btn btn-small" onclick="unequipItem('${item.id}')" 
                                style="background: #c44536; margin-left: 10px; padding: 5px 8px; font-size: 12px;">
                            –°–Ω—è—Ç—å
                        </button>
                    ` : '<span style="color: #8b7d6b;">–ù–µ —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–æ</span>'}
                </div>
            </div>
        `;
    });

    const modifiers = inventorySystem.getCombatModifiers();
    html += `
        <div style="margin-top: 15px; padding-top: 10px; border-top: 2px solid #5a3928;">
            <h5 style="color: #d4af37; margin-bottom: 5px;">–ë–æ–µ–≤—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã:</h5>
            <div style="font-size: 0.9em; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <div>–ê—Ç–∞–∫–∞: ${modifiers.attack >= 0 ? '+' : ''}${modifiers.attack}</div>
                <div>–ó–∞—â–∏—Ç–∞: +${modifiers.armorClass}</div>
                <div>–î–≤–∏–∂–µ–Ω–∏–µ: ${modifiers.movement >= 0 ? '+' : ''}${modifiers.movement}</div>
            </div>
        </div>
    `;

    return html;
}

function renderItemOptions(category) {
    const items = itemTemplates[category];
    if (!items) return '<option value="">–ù–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–æ–≤</option>';
    
    return Object.values(items).map(item => 
        `<option value="${item.id}">${item.name} (${item.value} –∑–æ–ª.)</option>`
    ).join('');
}

function renderInventoryItems(inventorySystem) {
    if (inventorySystem.items.length === 0) {
        return '<p style="text-align: center; color: #8b7d6b; padding: 20px;">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç</p>';
    }

    let html = '';
    inventorySystem.items.forEach(item => {
        const weight = (item.weight * (item.quantity || 1)).toFixed(1);
        html += `
            <div class="inventory-item" data-name="${item.name.toLowerCase()}" data-type="${item.type}">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <strong style="color: #d4af37;">${item.name}</strong>
                        ${item.quantity > 1 ? `
                            <span style="background: #8b4513; color: #e0d0c0; padding: 2px 8px; 
                                  border-radius: 4px; font-size: 0.9em; margin-left: 10px;">√ó${item.quantity}</span>
                        ` : ''}
                        ${item.equipped ? `<span style="color: #27ae60; margin-left: 10px;">[–≠–∫–∏–ø–∏—Ä–æ–≤–∞–Ω–æ]</span>` : ''}
                        <div style="color: #b8a28a; font-size: 0.9em; margin-top: 5px;">${item.description}</div>
                    </div>
                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                        ${!item.equipped ? `
                            <button class="btn btn-small" onclick="equipItem('${item.id}')" 
                                    style="background: #27ae60; padding: 5px 8px; font-size: 12px;">
                                –≠–∫–∏–ø–∏—Ä–æ–≤–∞—Ç—å
                            </button>
                        ` : `
                            <button class="btn btn-small" onclick="unequipItem('${item.id}')" 
                                    style="background: #c44536; padding: 5px 8px; font-size: 12px;">
                                –°–Ω—è—Ç—å
                            </button>
                        `}
                        ${item.type === 'potion' || item.type === 'food' ? `
                            <button class="btn btn-small" onclick="useItem('${item.id}')" 
                                    style="background: #3498db; padding: 5px 8px; font-size: 12px;">
                                –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
                            </button>
                        ` : ''}
                        <button class="btn btn-small" onclick="removeItem('${item.id}')" 
                                style="background: #e74c3c; padding: 5px 8px; font-size: 12px;">
                            –í—ã–±—Ä–æ—Å–∏—Ç—å
                        </button>
                    </div>
                </div>
                <div style="display: flex; justify-content: space-between; color: #8b7d6b; font-size: 0.8em;">
                    <span>–í–µ—Å: ${weight} –∫–≥</span>
                    <span>–°—Ç–æ–∏–º–æ—Å—Ç—å: ${item.value} –∑–æ–ª.</span>
                    <span>–¢–∏–ø: ${getItemTypeText(item.type)}</span>
                </div>
            </div>
        `;
    });

    return html;
}

// ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========

function getEncumbranceColor(level) {
    const colors = {
        'none': '#27ae60',
        'light': '#f39c12', 
        'medium': '#e67e22',
        'heavy': '#e74c3c'
    };
    return colors[level] || '#8b7d6b';
}

function getEncumbranceText(level) {
    const texts = {
        'none': '–ù–µ—Ç',
        'light': '–õ–µ–≥–∫–∞—è',
        'medium': '–°—Ä–µ–¥–Ω—è—è',
        'heavy': '–¢—è–∂–µ–ª–∞—è'
    };
    return texts[level] || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
}

function getItemTypeText(type) {
    const types = {
        'weapon': '–û—Ä—É–∂–∏–µ',
        'shield': '–©–∏—Ç',
        'armor': '–ë—Ä–æ–Ω—è',
        'light_source': '–ò—Å—Ç–æ—á–Ω–∏–∫ —Å–≤–µ—Ç–∞',
        'ammunition': '–ë–æ–µ–ø—Ä–∏–ø–∞—Å—ã',
        'potion': '–ó–µ–ª—å–µ',
        'tool': '–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç',
        'food': '–ï–¥–∞',
        'camping': '–ö–µ–º–ø–∏–Ω–≥'
    };
    return types[type] || type;
}

// ========== –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ò–ù–í–ï–ù–¢–ê–†–ï–ú ==========

function updateItemOptions(category) {
    const itemSelect = document.getElementById('itemSelect');
    if (itemSelect) {
        itemSelect.innerHTML = renderItemOptions(category);
    }
}

function addItemToInventory() {
    if (!currentCharacter) return;

    const category = document.getElementById('itemCategory').value;
    const itemId = document.getElementById('itemSelect').value;
    const quantity = parseInt(document.getElementById('itemQuantity').value) || 1;

    const itemTemplate = itemTemplates[category]?.[itemId];
    if (!itemTemplate) {
        alert('–ü—Ä–µ–¥–º–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω!');
        return;
    }

    const inventorySystem = new InventorySystem(currentCharacter);
    inventorySystem.addItem(itemTemplate, quantity);
    
    alert(`‚úÖ "${itemTemplate.name}" –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å!`);
    initializeInventoryInterface();
}

function equipItem(itemId) {
    if (!currentCharacter) return;

    const inventorySystem = new InventorySystem(currentCharacter);
    if (inventorySystem.equipItem(itemId)) {
        alert('‚úÖ –ü—Ä–µ–¥–º–µ—Ç —ç–∫–∏–ø–∏—Ä–æ–≤–∞–Ω!');
        initializeInventoryInterface();
    } else {
        alert('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —ç–∫–∏–ø–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è.');
    }
}

function unequipItem(itemId) {
    if (!currentCharacter) return;

    const inventorySystem = new InventorySystem(currentCharacter);
    if (inventorySystem.unequipItem(itemId)) {
        alert('‚úÖ –ü—Ä–µ–¥–º–µ—Ç —Å–Ω—è—Ç!');
        initializeInventoryInterface();
    }
}

function useItem(itemId) {
    if (!currentCharacter) return;

    const inventorySystem = new InventorySystem(currentCharacter);
    const result = inventorySystem.useItem(itemId);
    
    if (result) {
        if (typeof result === 'object') {
            alert(`‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ: ${result.effect}`);
        } else {
            alert('‚úÖ –ü—Ä–µ–¥–º–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω!');
        }
        initializeInventoryInterface();
    } else {
        alert('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–µ–¥–º–µ—Ç!');
    }
}

function removeItem(itemId) {
    if (!currentCharacter) return;

    if (confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–±—Ä–æ—Å–∏—Ç—å —ç—Ç–æ—Ç –ø—Ä–µ–¥–º–µ—Ç?')) {
        const inventorySystem = new InventorySystem(currentCharacter);
        if (inventorySystem.removeItem(itemId)) {
            alert('‚úÖ –ü—Ä–µ–¥–º–µ—Ç –≤—ã–±—Ä–æ—à–µ–Ω!');
            initializeInventoryInterface();
        }
    }
}

function filterInventoryItems(searchTerm) {
    const items = document.querySelectorAll('.inventory-item');
    const term = searchTerm.toLowerCase();
    
    items.forEach(item => {
        const itemName = item.getAttribute('data-name');
        const itemType = item.getAttribute('data-type');
        const matches = itemName.includes(term) || itemType.includes(term);
        item.style.display = matches ? 'block' : 'none';
    });
}

function showQuickEquipment() {
    if (!currentCharacter) return;

    const inventorySystem = new InventorySystem(currentCharacter);
    
    const starterKit = [
        itemTemplates.weapons.shortsword,
        itemTemplates.armor.leather_armor,
        itemTemplates.shields.buckler,
        itemTemplates.light_sources.torch,
        itemTemplates.potions.healing_potion,
        itemTemplates.misc.rope,
        itemTemplates.misc.rations
    ];

    starterKit.forEach(item => {
        inventorySystem.addItem(item);
    });

    alert('üéÅ –°—Ç–∞—Ä—Ç–æ–≤—ã–π –Ω–∞–±–æ—Ä –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å!');
    initializeInventoryInterface();
}

function clearInventory() {
    if (!currentCharacter) return;

    if (confirm('‚ùå –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—á–∏—Å—Ç–∏—Ç—å –≤–µ—Å—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å!')) {
        const inventorySystem = new InventorySystem(currentCharacter);
        inventorySystem.items = [];
        inventorySystem.equipped = {
            weapon: null,
            shield: null,
            armor: null,
            light_source: null
        };
        inventorySystem.saveInventory();
        alert('‚úÖ –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –æ—á–∏—â–µ–Ω!');
        initializeInventoryInterface();
    }
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

console.log('‚úÖ inventory.js –∑–∞–≥—Ä—É–∂–µ–Ω! –°–∏—Å—Ç–µ–º–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è –≥–æ—Ç–æ–≤–∞.');
            // dice.js - –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫—É–±–∏–∫–æ–≤ –∏ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–≤ D&D

// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========

let diceRollHistory = [];

// ========== –û–°–ù–û–í–ù–ê–Ø –°–ò–°–¢–ï–ú–ê –ö–£–ë–ò–ö–û–í ==========

function rollDice(sides, count = 1) {
    let results = [];
    let total = 0;
    
    for (let i = 0; i < count; i++) {
        const result = Math.floor(Math.random() * sides) + 1;
        results.push(result);
        total += result;
    }
    
    return { results, total };
}

function rollSkillCheck(skillValue, modifiers = 0) {
    const roll = rollDice(20, 1);
    const totalRoll = roll.total + modifiers;
    const success = totalRoll >= skillValue;
    
    let critical = 'normal';
    if (roll.total === 20) critical = 'success';
    if (roll.total === 1) critical = 'failure';
    
    return {
        roll: roll.results,
        total: totalRoll,
        success: success,
        critical: critical
    };
}

// ========== –ò–ù–¢–ï–†–§–ï–ô–° –°–ò–°–¢–ï–ú–´ –ö–£–ë–ò–ö–û–í ==========

function initializeDiceSystem() {
    const diceTab = document.getElementById('dice-tab');
    if (!diceTab) return;

    diceTab.innerHTML = `
        <div style="margin-bottom: 20px;">
            <h2 class="section-title">üé≤ –°–∏—Å—Ç–µ–º–∞ –ö—É–±–∏–∫–æ–≤</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div>
                    <h3 style="color: #d4af37; margin-bottom: 15px;">üéØ –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ –∫—É–±–∏–∫–∏</h3>
                    
                    <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin: 20px 0; flex-wrap: wrap;">
                        <span style="color: #d4af37;">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:</span>
                        <input type="number" id="diceCount" value="1" min="1" max="10"
                               style="width: 80px; padding: 12px; border: 2px solid #8b4513; border-radius: 4px; 
                               background: #1a0f0b; color: #e0d0c0; text-align: center; font-size: 16px;">
                    </div>

                    <div style="display: flex; flex-wrap: wrap; gap: 10px; margin: 20px 0; justify-content: center; align-items: center;">
                        <button class="btn btn-dice" onclick="rollDiceUI('coin')">ü™ô –ú–æ–Ω–µ—Ç–∫–∞</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(4)">D4</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(6)">D6</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(8)">D8</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(10)">D10</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(12)">D12</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(20)">D20</button>
                        <button class="btn btn-dice" onclick="rollDiceUI(100)">D100</button>
                        <div style="display: flex; gap: 5px; align-items: center;">
                            <button class="btn btn-dice" onclick="rollCustomDiceUI()">‚ö´ –ö–∞—Å—Ç–æ–º–Ω—ã–π</button>
                            <input type="number" id="customDiceSides" value="6" 
                                   min="2" max="1000" placeholder="–ì—Ä–∞–Ω–∏"
                                   style="width: 80px; padding: 12px; border: 2px solid #8b4513; border-radius: 4px; 
                                   background: #1a0f0b; color: #e0d0c0; text-align: center; font-size: 16px;">
                        </div>
                    </div>
                </div>
                
                <div>
                    <h3 style="color: #d4af37; margin-bottom: 15px;">üå§Ô∏è –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –∫—É–±–∏–∫–∏</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <button class="btn btn-dice" onclick="rollWeatherDiceUI()">üå¶Ô∏è –ü–æ–≥–æ–¥–∞</button>
                        <button class="btn btn-dice" onclick="rollFogDiceUI()">üå´Ô∏è –¢—É–º–∞–Ω</button>
                        <button class="btn btn-dice" onclick="rollEncounterDice()">üëπ –°–ª—É—á–∞–π–Ω–∞—è –≤—Å—Ç—Ä–µ—á–∞</button>
                        <button class="btn btn-dice" onclick="rollLootDice()">üíé –î–æ–±—ã—á–∞</button>
                        <button class="btn btn-dice" onclick="rollNPCdice()">üë§ –°–ª—É—á–∞–π–Ω—ã–π NPC</button>
                        <button class="btn btn-dice" onclick="rollLocationDice()">üè∞ –õ–æ–∫–∞—Ü–∏—è</button>
                        <button class="btn btn-dice" onclick="rollQuestDice()">üìú –ö–≤–µ—Å—Ç</button>
                        <button class="btn btn-dice" onclick="rollMagicItemDice()">‚ú® –ú–∞–≥–∏—á–µ—Å–∫–∏–π –ø—Ä–µ–¥–º–µ—Ç</button>
                    </div>
                    
                    <div style="background: #3d2418; padding: 15px; border-radius: 6px;">
                        <h4 style="color: #d4af37; margin-bottom: 10px;">üìä –ò—Å—Ç–æ—Ä–∏—è –±—Ä–æ—Å–∫–æ–≤</h4>
                        <div id="diceHistory" style="max-height: 150px; overflow-y: auto; font-size: 0.9em;">
                            <p style="color: #8b7d6b; text-align: center;">–ë—Ä–æ—Å–∫–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="diceResults" style="text-align: center; margin: 30px 0; min-height: 100px; 
                 background: #3d2418; padding: 20px; border-radius: 8px; border: 2px solid #5a3928;">
                <p style="color: #8b7d6b;">–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—Ä–æ—Å–∫–æ–≤ –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –∑–¥–µ—Å—å</p>
            </div>

            <div style="background: #3d2418; padding: 20px; border-radius: 8px; border: 2px solid #5a3928;">
                <h3 style="color: #d4af37; margin-bottom: 15px;">üé≤ –ë—ã—Å—Ç—Ä—ã–µ –±—Ä–æ—Å–∫–∏ –Ω–∞–≤—ã–∫–æ–≤</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                    <button class="btn btn-roll" onclick="quickSkillCheck('–ê—Ç–∞–∫–∞')">‚öîÔ∏è –ê—Ç–∞–∫–∞</button>
                    <button class="btn btn-roll" onclick="quickSkillCheck('–ó–∞—â–∏—Ç–∞')">üõ°Ô∏è –ó–∞—â–∏—Ç–∞</button>
                    <button class="btn btn-roll" onclick="quickSkillCheck('–°–∫—Ä—ã—Ç–Ω–æ—Å—Ç—å')">üëª –°–∫—Ä—ã—Ç–Ω–æ—Å—Ç—å</button>
                    <button class="btn btn-roll" onclick="quickSkillCheck('–í–æ—Å–ø—Ä–∏—è—Ç–∏–µ')">üëÅÔ∏è –í–æ—Å–ø—Ä–∏—è—Ç–∏–µ</button>
                    <button class="btn btn-roll" onclick="quickSkillCheck('–ö—Ä–∞—Å–Ω–æ—Ä–µ—á–∏–µ')">üí¨ –ö—Ä–∞—Å–Ω–æ—Ä–µ—á–∏–µ</button>
                    <button class="btn btn-roll" onclick="quickSkillCheck('–ú–∞–≥–∏—è')">üîÆ –ú–∞–≥–∏—è</button>
                </div>
            </div>
        </div>
    `;
}

// ========== –û–°–ù–û–í–ù–´–ï –§–£–ù–ö–¶–ò–ò –ë–†–û–°–ö–û–í ==========

function rollDiceUI(diceType) {
    const count = parseInt(document.getElementById('diceCount').value) || 1;
    let results = [];
    let total = 0;
    let diceName = '';
    
    if (diceType === 'coin') {
        for (let i = 0; i < count; i++) {
            const result = Math.random() > 0.5 ? '–û—Ä—ë–ª' : '–†–µ—à–∫–∞';
            results.push(result);
        }
        diceName = '–ú–æ–Ω–µ—Ç–∫–∞';
    } else {
        for (let i = 0; i < count; i++) {
            const result = Math.floor(Math.random() * diceType) + 1;
            results.push(result);
            total += result;
        }
        diceName = `D${diceType}`;
    }
    
    displayDiceResults(diceName, count, results, total);
    addToDiceHistory(diceName, count, results, total);
}

function rollCustomDiceUI() {
    const sides = parseInt(document.getElementById('customDiceSides').value) || 6;
    if (sides < 2) {
        alert('–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥—Ä–∞–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –º–µ–Ω—å—à–µ 2!');
        return;
    }
    rollDiceUI(sides);
}

function displayDiceResults(diceName, count, results, total) {
    const container = document.getElementById('diceResults');
    let resultHTML = '';
    
    if (diceName === '–ú–æ–Ω–µ—Ç–∫–∞') {
        resultHTML = `<h3 style="color: #d4af37;">${diceName} (${count} —Ä–∞–∑):</h3>`;
        resultHTML += `<div style="font-size: 1.5em; margin: 20px 0;">${results.join(', ')}</div>`;
    } else {
        resultHTML = `<h3 style="color: #d4af37;">–ë—Ä–æ—Å–æ–∫ ${count}${diceName}:</h3>`;
        resultHTML += `<div style="font-size: 1.5em; margin: 20px 0;">${results.join(' + ')}`;
        if (count > 1) {
            resultHTML += ` = <strong style="color: #d4af37;">${total}</strong>`;
        }
        resultHTML += `</div>`;
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –∫—É–±–∏–∫–æ–≤
        resultHTML += `<div class="dice-rolls">`;
        results.forEach((result, index) => {
            resultHTML += `<div class="dice" style="animation-delay: ${index * 0.1}s;">${result}</div>`;
        });
        resultHTML += `</div>`;
    }
    
    container.innerHTML = resultHTML;
}

function addToDiceHistory(diceName, count, results, total) {
    const timestamp = new Date().toLocaleTimeString();
    let entry = '';
    
    if (diceName === '–ú–æ–Ω–µ—Ç–∫–∞') {
        entry = `${timestamp} - ${diceName}: ${results.join(', ')}`;
    } else {
        entry = `${timestamp} - ${count}${diceName}: [${results.join(', ')}]`;
        if (count > 1) {
            entry += ` = ${total}`;
        }
    }
    
    diceRollHistory.unshift(entry);
    if (diceRollHistory.length > 15) diceRollHistory.pop();
    renderDiceHistory();
}

function renderDiceHistory() {
    const container = document.getElementById('diceHistory');
    if (!container) return;

    if (diceRollHistory.length === 0) {
        container.innerHTML = '<p style="color: #8b7d6b; text-align: center;">–ë—Ä–æ—Å–∫–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</p>';
        return;
    }
    
    let historyHTML = '';
    diceRollHistory.forEach(entry => {
        historyHTML += `<div style="padding: 5px 0; border-bottom: 1px solid #3d2418;">${entry}</div>`;
    });
    
    container.innerHTML = historyHTML;
}

// ========== –°–ü–ï–¶–ò–ê–õ–¨–ù–´–ï –ì–ï–ù–ï–†–ê–¢–û–†–´ ==========

function rollWeatherDiceUI() {
    const weatherTypes = [
        { name: "‚òÄÔ∏è –Ø—Å–Ω–æ", description: "–û—Ç–ª–∏—á–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å" },
        { name: "üå§Ô∏è –°–ª–∞–±–∞—è –æ–±–ª–∞—á–Ω–æ—Å—Ç—å", description: "–•–æ—Ä–æ—à–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å" },
        { name: "‚òÅÔ∏è –û–±–ª–∞—á–Ω–æ", description: "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å" },
        { name: "üå¶Ô∏è –°–ª–∞–±—ã–π –¥–æ–∂–¥—å", description: "–ù–µ–±–æ–ª—å—à–æ–π —à—Ç—Ä–∞—Ñ –∫ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—é" },
        { name: "üåßÔ∏è –î–æ–∂–¥—å", description: "–®—Ç—Ä–∞—Ñ –∫ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—é –∏ —Å—Ç—Ä–µ–ª—å–±–µ" },
        { name: "‚õàÔ∏è –ì—Ä–æ–∑–∞", description: "–°–∏–ª—å–Ω—ã–π —à—Ç—Ä–∞—Ñ –∫ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—é –∏ —Å—Ç—Ä–µ–ª—å–±–µ" },
        { name: "üå´Ô∏è –¢—É–º–∞–Ω", description: "–°–∏–ª—å–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å" },
        { name: "‚ùÑÔ∏è –°–Ω–µ–≥–æ–ø–∞–¥", description: "–û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å –∏ —Å–ª–æ–∂–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ" }
    ];
    
    const roll = rollDice(weatherTypes.length, 1).total - 1;
    const weather = weatherTypes[roll];
    
    displaySpecialResult('–ü–æ–≥–æ–¥–∞', weather.name, weather.description);
    addToDiceHistory('–ü–æ–≥–æ–¥–∞', 1, [weather.name], 0);
}

function rollFogDiceUI() {
    const fogTypes = [
        { name: "üå´Ô∏è –õ–µ–≥–∫–∏–π —Ç—É–º–∞–Ω", description: "-2 –∫ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—é" },
        { name: "üå´Ô∏èÔ∏è –°—Ä–µ–¥–Ω–∏–π —Ç—É–º–∞–Ω", description: "-4 –∫ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—é" },
        { name: "üî¥ –ì—É—Å—Ç–æ–π —Ç—É–º–∞–Ω", description: "-6 –∫ –≤–æ—Å–ø—Ä–∏—è—Ç–∏—é, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏" },
        { name: "‚ùå –¢—É–º–∞–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç", description: "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å" }
    ];
    
    const roll = rollDice(fogTypes.length, 1).total - 1;
    const fog = fogTypes[roll];
    
    displaySpecialResult('–¢—É–º–∞–Ω', fog.name, fog.description);
    addToDiceHistory('–¢—É–º–∞–Ω', 1, [fog.name], 0);
}

function rollEncounterDice() {
    const encounters = {
        peaceful: [
            "üë®‚Äçüåæ –ì—Ä—É–ø–ø–∞ —Ñ–µ—Ä–º–µ—Ä–æ–≤",
            "üõí –¢–æ—Ä–≥–æ–≤—ã–π –∫–∞—Ä–∞–≤–∞–Ω", 
            "üßô‚Äç‚ôÇÔ∏è –°—Ç—Ä–∞–Ω—Å—Ç–≤—É—é—â–∏–π –º–∞–≥",
            "üè∞ –ö–æ—Ä–æ–ª–µ–≤—Å–∫–∏–π –ø–∞—Ç—Ä—É–ª—å",
            "üö∂‚Äç‚ôÇÔ∏è –ü—É—Ç–Ω–∏–∫–∏",
            "üé≠ –ë—Ä–æ–¥—è—á–∏–µ –∞—Ä—Ç–∏—Å—Ç—ã"
        ],
        hostile: [
            "üíÄ –ë–∞–Ω–¥–∞ —Ä–∞–∑–±–æ–π–Ω–∏–∫–æ–≤",
            "üê∫ –°—Ç–∞—è –≤–æ–ª–∫–æ–≤",
            "üêª –ú–µ–¥–≤–µ–¥—å-—à–∞—Ç—É–Ω",
            "üè¥‚Äç‚ò†Ô∏è –ü–∏—Ä–∞—Ç—ã",
            "üëπ –ì–æ–±–ª–∏–Ω—ã",
            "üêâ –ú–æ–ª–æ–¥–æ–π –¥—Ä–∞–∫–æ–Ω"
        ],
        mysterious: [
            "üå≤ –õ–µ—Å–Ω—ã–µ –¥—É—Ö–∏",
            "üëª –ü—Ä–∏–∑—Ä–∞–∫–∏",
            "üîÆ –¢–∞–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –Ω–µ–∑–Ω–∞–∫–æ–º–µ—Ü",
            "üèõÔ∏è –î—Ä–µ–≤–Ω–∏–µ —Ä—É–∏–Ω—ã",
            "üíé –ó–∞–≥–∞–¥–æ—á–Ω—ã–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç",
            "üåå –ü–æ—Ä—Ç–∞–ª –≤ –¥—Ä—É–≥–æ–µ –∏–∑–º–µ—Ä–µ–Ω–∏–µ"
        ]
    };
    
    const encounterTypeRoll = rollDice(3, 1).total;
    let encounterType, encounterPool;
    
    if (encounterTypeRoll === 1) {
        encounterType = "–ú–∏—Ä–Ω–∞—è";
        encounterPool = encounters.peaceful;
    } else if (encounterTypeRoll === 2) {
        encounterType = "–í—Ä–∞–∂–¥–µ–±–Ω–∞—è";
        encounterPool = encounters.hostile;
    } else {
        encounterType = "–ó–∞–≥–∞–¥–æ—á–Ω–∞—è";
        encounterPool = encounters.mysterious;
    }
    
    const encounterRoll = rollDice(encounterPool.length, 1).total - 1;
    const encounter = encounterPool[encounterRoll];
    
    displaySpecialResult(`–°–ª—É—á–∞–π–Ω–∞—è –≤—Å—Ç—Ä–µ—á–∞ (${encounterType})`, encounter, "");
    addToDiceHistory('–í—Å—Ç—Ä–µ—á–∞', 1, [encounter], 0);
}

function rollLootDice() {
    const lootTables = {
        common: [
            "10 –∑–æ–ª–æ—Ç—ã—Ö –º–æ–Ω–µ—Ç",
            "–ü—Ä–æ—Å—Ç–æ–µ –∑–µ–ª—å–µ –ª–µ—á–µ–Ω–∏—è", 
            "–ö–∏–Ω–∂–∞–ª",
            "–§–∞–∫–µ–ª",
            "–í–µ—Ä–µ–≤–∫–∞ (15–º)",
            "–°—É—Ö–æ–π –ø–∞–µ–∫"
        ],
        uncommon: [
            "50 –∑–æ–ª–æ—Ç—ã—Ö –º–æ–Ω–µ—Ç",
            "–ö–æ–ª—å—á—É–≥–∞",
            "–ö–æ—Ä–æ—Ç–∫–∏–π –º–µ—á",
            "–ú–∞–ª–æ–µ –∑–µ–ª—å–µ –º–∞–Ω—ã",
            "–°–≤–∏—Ç–æ–∫ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è",
            "–î—Ä–∞–≥–æ—Ü–µ–Ω–Ω—ã–π –∫–∞–º–µ–Ω—å"
        ],
        rare: [
            "100 –∑–æ–ª–æ—Ç—ã—Ö –º–æ–Ω–µ—Ç",
            "–õ–∞—Ç–Ω–∞—è –±—Ä–æ–Ω—è",
            "–í–æ–ª—à–µ–±–Ω—ã–π –º–µ—á",
            "–°–∏–ª—å–Ω–æ–µ –∑–µ–ª—å–µ –ª–µ—á–µ–Ω–∏—è",
            "–ú–∞–≥–∏—á–µ—Å–∫–∏–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç",
            "–î—Ä–µ–≤–Ω—è—è —Ä–µ–ª–∏–∫–≤–∏—è"
        ]
    };
    
    const rarityRoll = rollDice(100, 1).total;
    let lootTable, rarity;
    
    if (rarityRoll <= 60) {
        lootTable = lootTables.common;
        rarity = "–û–±—ã—á–Ω–∞—è";
    } else if (rarityRoll <= 90) {
        lootTable = lootTables.uncommon;
        rarity = "–ù–µ–æ–±—ã—á–Ω–∞—è";
    } else {
        lootTable = lootTables.rare;
        rarity = "–†–µ–¥–∫–∞—è";
    }
    
    const lootRoll = rollDice(lootTable.length, 1).total - 1;
    const loot = lootTable[lootRoll];
    
    displaySpecialResult(`–î–æ–±—ã—á–∞ (${rarity})`, loot, "");
    addToDiceHistory('–î–æ–±—ã—á–∞', 1, [loot], 0);
}

function rollNPCdice() {
    const personalities = [
        "–î—Ä—É–∂–µ–ª—é–±–Ω—ã–π", "–ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π", "–í–µ—Å–µ–ª—ã–π", "–£–≥—Ä—é–º—ã–π", "–ú—É–¥—Ä—ã–π", 
        "–ì–ª—É–ø—ã–π", "–•—Ä–∞–±—Ä—ã–π", "–¢—Ä—É—Å–ª–∏–≤—ã–π", "–ß–µ—Å—Ç–Ω—ã–π", "–õ–∂–∏–≤—ã–π"
    ];
    
    const occupations = [
        "–ö—É–∑–Ω–µ—Ü", "–¢–æ—Ä–≥–æ–≤–µ—Ü", "–°—Ç—Ä–∞–∂–Ω–∏–∫", "–ö—Ä–µ—Å—Ç—å—è–Ω–∏–Ω", "–ú–∞–≥", 
        "–ñ—Ä–µ—Ü", "–í–æ—Ä", "–ê—Ä–∏—Å—Ç–æ–∫—Ä–∞—Ç", "–ù–∞–µ–º–Ω–∏–∫", "–ü—É—Ç–µ—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫"
    ];
    
    const goals = [
        "–ò—â–µ—Ç –ø–æ–º–æ—â—å", "–ü—Ä–æ–¥–∞–µ—Ç —Ç–æ–≤–∞—Ä—ã", "–î–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ", "–ü—Ä–æ—Å–∏—Ç –º–∏–ª–æ—Å—Ç—ã–Ω—é",
        "–†–∞—Å—Å–∫–∞–∑—ã–≤–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é", "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ—Ç –æ–± –æ–ø–∞—Å–Ω–æ—Å—Ç–∏", "–ò—â–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é",
        "–°–∫—Ä—ã–≤–∞–µ—Ç—Å—è –æ—Ç –ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª–µ–π", "–ò—â–µ—Ç —Å–ø—É—Ç–Ω–∏–∫–æ–≤", "–û—Ç–¥—ã—Ö–∞–µ—Ç"
    ];
    
    const personality = personalities[rollDice(personalities.length, 1).total - 1];
    const occupation = occupations[rollDice(occupations.length, 1).total - 1];
    const goal = goals[rollDice(goals.length, 1).total - 1];
    
    const npcDescription = `${personality} ${occupation.toLowerCase()}. ${goal}.`;
    
    displaySpecialResult("–°–ª—É—á–∞–π–Ω—ã–π NPC", npcDescription, "");
    addToDiceHistory('NPC', 1, [npcDescription], 0);
}

function rollLocationDice() {
    const locations = [
        { name: "üè∞ –ó–∞–±—Ä–æ—à–µ–Ω–Ω—ã–π –∑–∞–º–æ–∫", description: "–ü–æ–ª–æ–Ω –æ–ø–∞—Å–Ω–æ—Å—Ç–µ–π –∏ —Å–æ–∫—Ä–æ–≤–∏—â" },
        { name: "üå≤ –¢–∞–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π –ª–µ—Å", description: "–î—Ä–µ–≤–Ω–∏–µ –¥–µ—Ä–µ–≤—å—è –∏ –º–∞–≥–∏—á–µ—Å–∫–∏–µ —Å—É—â–µ—Å—Ç–≤–∞" },
        { name: "üèîÔ∏è –ì–æ—Ä–Ω—ã–π –ø–µ—Ä–µ–≤–∞–ª", description: "–°–ª–æ–∂–Ω—ã–π –ø—É—Ç—å —Å –ø—Ä–µ–∫—Ä–∞—Å–Ω—ã–º–∏ –≤–∏–¥–∞–º–∏" },
        { name: "üèòÔ∏è –î–µ—Ä–µ–≤–Ω—è", description: "–ú–∏—Ä–Ω—ã–µ –∂–∏—Ç–µ–ª–∏ –∏ –ø—Ä–æ—Å—Ç—ã–µ —É—Å–ª—É–≥–∏" },
        { name: "üåä –ü—Ä–∏–±—Ä–µ–∂–Ω—ã–µ –ø–µ—â–µ—Ä—ã", description: "–°–∫—Ä—ã—Ç—ã–µ –≥—Ä–æ—Ç—ã –∏ –º–æ—Ä—Å–∫–∏–µ —á—É–¥–æ–≤–∏—â–∞" },
        { name: "‚öíÔ∏è –ó–∞–±—Ä–æ—à–µ–Ω–Ω–∞—è —à–∞—Ö—Ç–∞", description: "–ë–æ–≥–∞—Ç—Å—Ç–≤–∞ –∏ –ø–æ–¥–∑–µ–º–Ω—ã–µ —É–∂–∞—Å—ã" },
        { name: "üèõÔ∏è –î—Ä–µ–≤–Ω–∏–π —Ö—Ä–∞–º", description: "–†–µ–ª–∏–∫–≤–∏–∏ –∏ –∑–∞–≥–∞–¥–æ—á–Ω—ã–µ —Ä–∏—Ç—É–∞–ª—ã" },
        { name: "üõ§Ô∏è –ü—Ä–æ—Å–µ–ª–æ—á–Ω–∞—è –¥–æ—Ä–æ–≥–∞", description: "–í—Å—Ç—Ä–µ—á–∏ —Å –ø—É—Ç–Ω–∏–∫–∞–º–∏ –∏ —Ä–∞–∑–±–æ–π–Ω–∏–∫–∞–º–∏" }
    ];
    
    const roll = rollDice(locations.length, 1).total - 1;
    const location = locations[roll];
    
    displaySpecialResult("–õ–æ–∫–∞—Ü–∏—è", location.name, location.description);
    addToDiceHistory('–õ–æ–∫–∞—Ü–∏—è', 1, [location.name], 0);
}

function rollQuestDice() {
    const questTypes = [
        { type: "üíÄ –£–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–µ", description: "–£–±–∏—Ç—å –º–æ–Ω—Å—Ç—Ä–∞ –∏–ª–∏ –∑–ª–æ–¥–µ—è" },
        { type: "üíé –ü–æ–∏—Å–∫", description: "–ù–∞–π—Ç–∏ –ø–æ—Ç–µ—Ä—è–Ω–Ω—ã–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç" },
        { type: "üè∞ –°–ø–∞—Å–µ–Ω–∏–µ", description: "–°–ø–∞—Å—Ç–∏ –∑–∞–ª–æ–∂–Ω–∏–∫–∞" },
        { type: "üìú –î–æ—Å—Ç–∞–≤–∫–∞", description: "–î–æ—Å—Ç–∞–≤–∏—Ç—å –≤–∞–∂–Ω–æ–µ –ø–æ—Å–ª–∞–Ω–∏–µ" },
        { type: "üïµÔ∏è‚Äç‚ôÇÔ∏è –†–∞—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ", description: "–†–∞—Å–∫—Ä—ã—Ç—å —Ç–∞–π–Ω—É" },
        { type: "‚öîÔ∏è –ó–∞—â–∏—Ç–∞", description: "–ó–∞—â–∏—Ç–∏—Ç—å –ª–æ–∫–∞—Ü–∏—é –æ—Ç –≤—Ä–∞–≥–æ–≤" }
    ];
    
    const rewards = [
        "50 –∑–æ–ª–æ—Ç—ã—Ö", "100 –∑–æ–ª–æ—Ç—ã—Ö", "–ú–∞–≥–∏—á–µ—Å–∫–∏–π –ø—Ä–µ–¥–º–µ—Ç", "–ó–µ–º–µ–ª—å–Ω—ã–π –Ω–∞–¥–µ–ª",
        "–¢–∏—Ç—É–ª", "–ë–ª–∞–≥–æ–¥–∞—Ä–Ω–æ—Å—Ç—å –ø—Ä–∞–≤–∏—Ç–µ–ª—è", "–î—Ä–µ–≤–Ω–µ–µ –∑–Ω–∞–Ω–∏–µ", "–°–æ—é–∑–Ω–∏–∫–∏"
    ];
    
    const quest = questTypes[rollDice(questTypes.length, 1).total - 1];
    const reward = rewards[rollDice(rewards.length, 1).total - 1];
    
    const questDescription = `${quest.type}: ${quest.description}. –ù–∞–≥—Ä–∞–¥–∞: ${reward}.`;
    
    displaySpecialResult("–ö–≤–µ—Å—Ç", questDescription, "");
    addToDiceHistory('–ö–≤–µ—Å—Ç', 1, [questDescription], 0);
}

function rollMagicItemDice() {
    const magicItems = [
        { name: "üî• –ü–ª–∞–º–µ–Ω–Ω—ã–π –º–µ—á", effect: "+2 –∫ –∞—Ç–∞–∫–µ, –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —É—Ä–æ–Ω –æ–≥–Ω–µ–º" },
        { name: "üõ°Ô∏è –©–∏—Ç –æ—Ç—Ä–∞–∂–µ–Ω–∏—è", effect: "+3 –∫ –∑–∞—â–∏—Ç–µ, —à–∞–Ω—Å –æ—Ç—Ä–∞–∑–∏—Ç—å –∑–∞–∫–ª–∏–Ω–∞–Ω–∏—è" },
        { name: "üß≠ –ö–æ–º–ø–∞—Å –∏—Å—Ç–∏–Ω—ã", effect: "–í—Å–µ–≥–¥–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –±–ª–∏–∂–∞–π—à—É—é –ø—Ä–∞–≤–¥—É" },
        { name: "üíç –ù–µ–≤–∏–¥–∏–º–æ—Å—Ç–∏", effect: "–ü–æ–∑–≤–æ–ª—è–µ—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—å—Å—è –Ω–µ–≤–∏–¥–∏–º—ã–º –Ω–∞ 1 –º–∏–Ω—É—Ç—É" },
        { name: "üìñ –ö–Ω–∏–≥–∞ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–π", effect: "–ü–æ–∑–≤–æ–ª—è–µ—Ç –≤—ã—É—á–∏—Ç—å 1 –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ" },
        { name: "ü•æ –°–∞–ø–æ–≥–∏ —Å–∫–æ—Ä–æ—Å—Ç–∏", effect: "+10 –∫ —Å–∫–æ—Ä–æ—Å—Ç–∏ –¥–≤–∏–∂–µ–Ω–∏—è" },
        { name: "üß§ –ü–µ—Ä—á–∞—Ç–∫–∏ —Å–∏–ª—ã", effect: "+2 –∫ —Å–∏–ª–µ –∏ –Ω–æ—à–µ–Ω–∏—é" },
        { name: "üëë –ö–æ—Ä–æ–Ω–∞ –º—É–¥—Ä–æ—Å—Ç–∏", effect: "+2 –∫–æ –≤—Å–µ–º –º–∞–≥–∏—á–µ—Å–∫–∏–º –Ω–∞–≤—ã–∫–∞–º" }
    ];
    
    const roll = rollDice(magicItems.length, 1).total - 1;
    const item = magicItems[roll];
    
    displaySpecialResult("–ú–∞–≥–∏—á–µ—Å–∫–∏–π –ø—Ä–µ–¥–º–µ—Ç", item.name, item.effect);
    addToDiceHistory('–ú–∞–≥. –ø—Ä–µ–¥–º–µ—Ç', 1, [item.name], 0);
}

function displaySpecialResult(title, result, description) {
    const container = document.getElementById('diceResults');
    container.innerHTML = `
        <h3 style="color: #d4af37;">${title}</h3>
        <div style="font-size: 1.5em; margin: 20px 0; color: #27ae60;">${result}</div>
        ${description ? `<div style="color: #b8a28a; font-size: 1.1em;">${description}</div>` : ''}
    `;
}

// ========== –ë–´–°–¢–†–´–ï –ë–†–û–°–ö–ò –ù–ê–í–´–ö–û–í ==========

function quickSkillCheck(skillName) {
    if (!currentCharacter) {
        alert('–°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞!');
        return;
    }

    const skillValue = currentCharacter.getSkillValue(skillName) || 10;
    const check = rollSkillCheck(skillValue);
    
    let resultText, resultClass;
    if (check.critical === 'success') {
        resultText = "üí´ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –£–°–ü–ï–•!";
        resultClass = "success";
    } else if (check.critical === 'failure') {
        resultText = "üí• –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ô –ü–†–û–í–ê–õ!";
        resultClass = "error";
    } else if (check.success) {
        resultText = "‚úÖ –£–°–ü–ï–•!";
        resultClass = "success";
    } else {
        resultText = "‚ùå –ù–ï–£–î–ê–ß–ê!";
        resultClass = "error";
    }

    const container = document.getElementById('diceResults');
    container.innerHTML = `
        <h3 style="color: #d4af37;">–ë—Ä–æ—Å–æ–∫ ${skillName} (${skillValue})</h3>
        <div class="dice-rolls">
            <div class="dice">${check.roll[0]}</div>
        </div>
        <div style="font-size: 1.5em; margin: 20px 0; color: #e0d0c0;">
            –†–µ–∑—É–ª—å—Ç–∞—Ç: <strong>${check.total}</strong>
        </div>
        <div class="${resultClass}" style="font-weight: bold; font-size: 1.3em; margin: 20px 0;">
            ${resultText}
        </div>
    `;

    addToDiceHistory(`–ù–∞–≤—ã–∫ ${skillName}`, 1, [check.roll[0]], check.total);
}

// ========== –£–¢–ò–õ–ò–¢–´ ==========

function clearDiceHistory() {
    diceRollHistory = [];
    renderDiceHistory();
}

function exportDiceHistory() {
    const historyText = diceRollHistory.join('\n');
    const blob = new Blob([historyText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = 'dice_history.txt';
    link.click();
    
    URL.revokeObjectURL(url);
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

console.log('‚úÖ dice.js –∑–∞–≥—Ä—É–∂–µ–Ω! –°–∏—Å—Ç–µ–º–∞ –∫—É–±–∏–∫–æ–≤ –≥–æ—Ç–æ–≤–∞.');
        // notes.js - –ü–æ–ª–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∑–∞–º–µ—Ç–æ–∫ D&D

// ========== –°–ò–°–¢–ï–ú–ê –ó–ê–ú–ï–¢–û–ö ==========

class NotesSystem {
    constructor() {
        this.notes = [];
        this.categories = ['–û–±—â–µ–µ', '–ö–≤–µ—Å—Ç—ã', '–ü–µ—Ä—Å–æ–Ω–∞–∂–∏', '–õ–æ–∫–∞—Ü–∏–∏', '–õ–æ—Ä', '–ò–¥–µ–∏'];
        this.loadNotes();
    }

    addNote(title, content, category = '–û–±—â–µ–µ') {
        const note = {
            id: 'note_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            title: title.trim(),
            content: content.trim(),
            category: category,
            expanded: false,
            created: new Date().toISOString(),
            updated: new Date().toISOString(),
            tags: []
        };
        
        this.notes.unshift(note);
        this.saveNotes();
        return note;
    }

    editNote(noteId, title, content, category) {
        const note = this.notes.find(n => n.id === noteId);
        if (note) {
            note.title = title.trim();
            note.content = content.trim();
            note.category = category;
            note.updated = new Date().toISOString();
            this.saveNotes();
            return true;
        }
        return false;
    }

    deleteNote(noteId) {
        const noteIndex = this.notes.findIndex(n => n.id === noteId);
        if (noteIndex !== -1) {
            this.notes.splice(noteIndex, 1);
            this.saveNotes();
            return true;
        }
        return false;
    }

    toggleNoteExpand(noteId) {
        const note = this.notes.find(n => n.id === noteId);
        if (note) {
            note.expanded = !note.expanded;
            this.saveNotes();
            return true;
        }
        return false;
    }

    searchNotes(searchTerm) {
        const term = searchTerm.toLowerCase();
        return this.notes.filter(note => 
            note.title.toLowerCase().includes(term) || 
            note.content.toLowerCase().includes(term) ||
            note.category.toLowerCase().includes(term)
        );
    }

    getNotesByCategory(category) {
        return this.notes.filter(note => note.category === category);
    }

    addTagToNote(noteId, tag) {
        const note = this.notes.find(n => n.id === noteId);
        if (note && !note.tags.includes(tag)) {
            note.tags.push(tag);
            note.updated = new Date().toISOString();
            this.saveNotes();
            return true;
        }
        return false;
    }

    removeTagFromNote(noteId, tag) {
        const note = this.notes.find(n => n.id === noteId);
        if (note) {
            const tagIndex = note.tags.indexOf(tag);
            if (tagIndex !== -1) {
                note.tags.splice(tagIndex, 1);
                note.updated = new Date().toISOString();
                this.saveNotes();
                return true;
            }
        }
        return false;
    }

    getAllTags() {
        const allTags = new Set();
        this.notes.forEach(note => {
            note.tags.forEach(tag => allTags.add(tag));
        });
        return Array.from(allTags);
    }

    getStats() {
        return {
            total: this.notes.length,
            byCategory: this.categories.reduce((acc, category) => {
                acc[category] = this.getNotesByCategory(category).length;
                return acc;
            }, {}),
            lastUpdated: this.notes.length > 0 ? 
                new Date(this.notes[0].updated).toLocaleDateString() : '–ù–µ—Ç –∑–∞–º–µ—Ç–æ–∫'
        };
    }

    saveNotes() {
        StorageSystem.set('dnd_notes', {
            notes: this.notes,
            categories: this.categories
        });
    }

    loadNotes() {
        const data = StorageSystem.get('dnd_notes', {
            notes: [],
            categories: this.categories
        });
        
        this.notes = data.notes;
        this.categories = data.categories;
    }

    exportNotes() {
        return JSON.stringify({
            notes: this.notes,
            categories: this.categories,
            exported: new Date().toISOString(),
            version: '1.0'
        }, null, 2);
    }

    importNotes(jsonData) {
        try {
            const data = JSON.parse(jsonData);
            if (data.notes && Array.isArray(data.notes)) {
                this.notes = data.notes;
                if (data.categories) {
                    this.categories = data.categories;
                }
                this.saveNotes();
                return this.notes.length;
            }
        } catch (error) {
            console.error('–û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ –∑–∞–º–µ—Ç–æ–∫:', error);
        }
        return 0;
    }

    clearAllNotes() {
        this.notes = [];
        this.saveNotes();
    }
}

// ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========

let notesSystem = new NotesSystem();

// ========== –ò–ù–¢–ï–†–§–ï–ô–° –°–ò–°–¢–ï–ú–´ –ó–ê–ú–ï–¢–û–ö ==========

function initializeNotesSystem() {
    const notesTab = document.getElementById('notes-tab');
    if (!notesTab) return;

    const stats = notesSystem.getStats();

    notesTab.innerHTML = `
        <div style="margin-bottom: 20px;">
            <h2 class="section-title">‚úçÔ∏è –°–∏—Å—Ç–µ–º–∞ –ó–∞–º–µ—Ç–æ–∫</h2>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div style="background: #3d2418; padding: 15px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 2em; color: #d4af37;">${stats.total}</div>
                    <div>–í—Å–µ–≥–æ –∑–∞–º–µ—Ç–æ–∫</div>
                </div>
                <div style="background: #3d2418; padding: 15px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 2em; color: #d4af37;">${Object.keys(stats.byCategory).length}</div>
                    <div>–ö–∞—Ç–µ–≥–æ—Ä–∏–π</div>
                </div>
                <div style="background: #3d2418; padding: 15px; border-radius: 6px; text-align: center;">
                    <div style="font-size: 1.2em; color: #d4af37;">${stats.lastUpdated}</div>
                    <div>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ</div>
                </div>
            </div>

            <div style="text-align: center; margin-bottom: 20px;">
                <button class="btn btn-plus" onclick="showAddNotePopup()">‚ûï –ù–æ–≤–∞—è –∑–∞–º–µ—Ç–∫–∞</button>
                <button class="btn btn-roll" onclick="showCategoryManager()">üìÇ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏</button>
                <button class="btn btn-roll" onclick="exportNotes()">üíæ –≠–∫—Å–ø–æ—Ä—Ç –∑–∞–º–µ—Ç–æ–∫</button>
                <button class="btn btn-roll" onclick="importNotes()">üì• –ò–º–ø–æ—Ä—Ç –∑–∞–º–µ—Ç–æ–∫</button>
                <button class="btn btn-minus" onclick="showClearAllPopup()">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ</button>
            </div>

            <div style="display: grid; grid-template-columns: 250px 1fr; gap: 20px;">
                <div style="background: #3d2418; padding: 20px; border-radius: 8px; border: 2px solid #5a3928;">
                    <h3 style="color: #d4af37; margin-bottom: 15px;">üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏</h3>
                    <div id="categoriesList">
                        ${renderCategoriesList()}
                    </div>
                    
                    <div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #5a3928;">
                        <h4 style="color: #d4af37; margin-bottom: 10px;">üè∑Ô∏è –¢–µ–≥–∏</h4>
                        <div id="tagsList">
                            ${renderTagsList()}
                        </div>
                    </div>
                </div>
                
                <div>
                    <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                        <input type="text" id="notesSearch" placeholder="üîç –ü–æ–∏—Å–∫ –≤ –∑–∞–º–µ—Ç–∫–∞—Ö..." 
                               style="flex: 1; padding: 12px; border: 2px solid #8b4513; 
                               border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                        <select id="sortNotes" style="padding: 12px; border: 2px solid #8b4513; 
                               border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                            <option value="newest">–°–Ω–∞—á–∞–ª–∞ –Ω–æ–≤—ã–µ</option>
                            <option value="oldest">–°–Ω–∞—á–∞–ª–∞ —Å—Ç–∞—Ä—ã–µ</option>
                            <option value="title">–ü–æ –Ω–∞–∑–≤–∞–Ω–∏—é</option>
                            <option value="updated">–ü–æ –∏–∑–º–µ–Ω–µ–Ω–∏—é</option>
                        </select>
                    </div>
                    
                    <div id="notesContainer">
                        ${renderNotes(notesSystem.notes)}
                    </div>
                </div>
            </div>
        </div>
    `;

    setupNotesEventListeners();
}

function renderCategoriesList() {
    const stats = notesSystem.getStats();
    let html = '';
    
    html += `<div class="category-item" data-category="all" style="margin-bottom: 10px;">
        <button class="btn btn-roll" onclick="filterNotesByCategory('all')" 
                style="width: 100%; text-align: left; justify-content: flex-start;">
            üìÅ –í—Å–µ –∑–∞–º–µ—Ç–∫–∏
            <span style="margin-left: auto; background: #8b4513; padding: 2px 8px; border-radius: 10px; font-size: 0.8em;">
                ${stats.total}
            </span>
        </button>
    </div>`;
    
    notesSystem.categories.forEach(category => {
        const count = stats.byCategory[category] || 0;
        html += `
            <div class="category-item" data-category="${category}" style="margin-bottom: 10px;">
                <button class="btn btn-roll" onclick="filterNotesByCategory('${category}')" 
                        style="width: 100%; text-align: left; justify-content: flex-start;">
                    üìÇ ${category}
                    <span style="margin-left: auto; background: #8b4513; padding: 2px 8px; border-radius: 10px; font-size: 0.8em;">
                        ${count}
                    </span>
                </button>
            </div>
        `;
    });
    
    return html;
}

function renderTagsList() {
    const tags = notesSystem.getAllTags();
    if (tags.length === 0) {
        return '<p style="color: #8b7d6b; font-size: 0.9em;">–¢–µ–≥–æ–≤ –ø–æ–∫–∞ –Ω–µ—Ç</p>';
    }
    
    let html = '';
    tags.forEach(tag => {
        html += `
            <span class="tag" onclick="filterNotesByTag('${tag}')" 
                  style="display: inline-block; background: #8b4513; color: #e0d0c0; 
                         padding: 2px 8px; margin: 2px; border-radius: 10px; font-size: 0.8em; 
                         cursor: pointer; transition: all 0.2s;">
                üè∑Ô∏è ${tag}
            </span>
        `;
    });
    return html;
}

function renderNotes(notesToRender) {
    if (notesToRender.length === 0) {
        return `
            <div style="text-align: center; padding: 50px; color: #8b7d6b;">
                <h3>–ó–∞–º–µ—Ç–æ–∫ –ø–æ–∫–∞ –Ω–µ—Ç</h3>
                <p>–°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–≤—É—é –∑–∞–º–µ—Ç–∫—É —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å!</p>
                <button class="btn btn-plus" onclick="showAddNotePopup()">–°–æ–∑–¥–∞—Ç—å –∑–∞–º–µ—Ç–∫—É</button>
            </div>
        `;
    }

    let html = '';
    notesToRender.forEach(note => {
        const preview = note.content.length > 200 ? note.content.substring(0, 200) + '...' : note.content;
        const createdDate = new Date(note.created).toLocaleDateString();
        const updatedDate = new Date(note.updated).toLocaleDateString();
        
        html += `
            <div class="note-item" data-note-id="${note.id}" data-category="${note.category}" 
                 data-tags="${note.tags.join(',')}" style="background: #3d2418; margin: 15px 0; padding: 20px; 
                 border-radius: 8px; border-left: 4px solid #27ae60; transition: all 0.3s ease;">
                <div class="note-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <span class="note-title" style="font-weight: bold; color: #d4af37; font-size: 1.2em;">${note.title}</span>
                        <span class="note-category" style="background: #5a3928; color: #b8a28a; padding: 2px 8px; 
                              border-radius: 10px; font-size: 0.8em; margin-left: 10px;">${note.category}</span>
                        ${note.tags.length > 0 ? `
                            <div style="margin-top: 5px;">
                                ${note.tags.map(tag => `
                                    <span class="note-tag" style="background: #8b4513; color: #e0d0c0; padding: 1px 6px; 
                                          margin: 2px; border-radius: 8px; font-size: 0.7em;">üè∑Ô∏è ${tag}</span>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                    <div class="note-actions" style="display: flex; gap: 8px;">
                        <button class="btn btn-small" onclick="editNote('${note.id}')" 
                                style="background: #3498db; padding: 6px 10px; font-size: 12px;">‚úèÔ∏è</button>
                        <button class="btn btn-small" onclick="showTagManager('${note.id}')" 
                                style="background: #9b59b6; padding: 6px 10px; font-size: 12px;">üè∑Ô∏è</button>
                        <button class="btn btn-small" onclick="toggleNoteExpand('${note.id}')" 
                                style="background: #8b4513; padding: 6px 10px; font-size: 12px;">
                            ${note.expanded ? '‚ñº' : '‚ñ∂'}
                        </button>
                        <button class="btn btn-small" onclick="deleteNote('${note.id}')" 
                                style="background: #c44536; padding: 6px 10px; font-size: 12px;">‚ùå</button>
                    </div>
                </div>
                <div class="note-preview" style="color: #b8a28a; font-size: 0.95em; line-height: 1.4; margin-bottom: 10px;">
                    ${note.expanded ? note.content.replace(/\n/g, '<br>') : preview.replace(/\n/g, '<br>')}
                </div>
                <div style="color: #8b7d6b; font-size: 0.8em; display: flex; justify-content: space-between;">
                    <span>–°–æ–∑–¥–∞–Ω–æ: ${createdDate}</span>
                    <span>–ò–∑–º–µ–Ω–µ–Ω–æ: ${updatedDate}</span>
                </div>
            </div>
        `;
    });

    return html;
}

// ========== –§–£–ù–ö–¶–ò–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –ó–ê–ú–ï–¢–ö–ê–ú–ò ==========

function setupNotesEventListeners() {
    const searchInput = document.getElementById('notesSearch');
    const sortSelect = document.getElementById('sortNotes');
    
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            filterNotes(this.value);
        });
    }
    
    if (sortSelect) {
        sortSelect.addEventListener('change', function() {
            sortNotes(this.value);
        });
    }
}

function showAddNotePopup() {
    showPopup(
        '‚úçÔ∏è –ù–æ–≤–∞—è –∑–∞–º–µ—Ç–∫–∞',
        `
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–ó–∞–≥–æ–ª–æ–≤–æ–∫:</label>
                <input type="text" id="newNoteTitle" placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∑–∞–º–µ—Ç–∫–∏" 
                       style="width: 100%; padding: 12px; border: 2px solid #8b4513; border-radius: 4px; 
                       background: #1a0f0b; color: #e0d0c0;">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</label>
                <select id="newNoteCategory" style="width: 100%; padding: 12px; border: 2px solid #8b4513; 
                      border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                    ${notesSystem.categories.map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–¢–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏:</label>
                <textarea id="newNoteContent" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏..." 
                          style="width: 100%; height: 300px; padding: 12px; border: 2px solid #8b4513; 
                          border-radius: 4px; background: #1a0f0b; color: #e0d0c0; resize: vertical;"></textarea>
            </div>
        `,
        [
            '<button class="btn btn-plus" onclick="addNewNote()">–î–æ–±–∞–≤–∏—Ç—å</button>',
            '<button class="btn btn-roll" onclick="closePopup(this.closest(\'.popup\'))">–û—Ç–º–µ–Ω–∞</button>'
        ]
    );
}

function addNewNote() {
    const title = document.getElementById('newNoteTitle').value.trim();
    const content = document.getElementById('newNoteContent').value.trim();
    const category = document.getElementById('newNoteCategory').value;
    
    if (!title) {
        alert('–í–≤–µ–¥–∏—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∑–∞–º–µ—Ç–∫–∏!');
        return;
    }
    
    if (!content) {
        alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏!');
        return;
    }

    notesSystem.addNote(title, content, category);
    initializeNotesSystem();
    closePopup(document.querySelector('.popup'));
}

function editNote(noteId) {
    const note = notesSystem.notes.find(n => n.id === noteId);
    if (!note) return;

    showPopup(
        '‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–º–µ—Ç–∫—É',
        `
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–ó–∞–≥–æ–ª–æ–≤–æ–∫:</label>
                <input type="text" id="editNoteTitle" value="${note.title}" 
                       style="width: 100%; padding: 12px; border: 2px solid #8b4513; border-radius: 4px; 
                       background: #1a0f0b; color: #e0d0c0;">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–ö–∞—Ç–µ–≥–æ—Ä–∏—è:</label>
                <select id="editNoteCategory" style="width: 100%; padding: 12px; border: 2px solid #8b4513; 
                      border-radius: 4px; background: #1a0f0b; color: #e0d0c0;">
                    ${notesSystem.categories.map(cat => 
                        `<option value="${cat}" ${cat === note.category ? 'selected' : ''}>${cat}</option>`
                    ).join('')}
                </select>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–¢–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏:</label>
                <textarea id="editNoteContent" 
                          style="width: 100%; height: 300px; padding: 12px; border: 2px solid #8b4513; 
                          border-radius: 4px; background: #1a0f0b; color: #e0d0c0; resize: vertical;">${note.content}</textarea>
            </div>
        `,
        [
            `<button class="btn btn-plus" onclick="saveEditedNote('${noteId}')">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>`,
            '<button class="btn btn-roll" onclick="closePopup(this.closest(\'.popup\'))">–û—Ç–º–µ–Ω–∞</button>'
        ]
    );
}

function saveEditedNote(noteId) {
    const title = document.getElementById('editNoteTitle').value.trim();
    const content = document.getElementById('editNoteContent').value.trim();
    const category = document.getElementById('editNoteCategory').value;
    
    if (!title) {
        alert('–í–≤–µ–¥–∏—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∑–∞–º–µ—Ç–∫–∏!');
        return;
    }
    
    if (!content) {
        alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏!');
        return;
    }

    if (notesSystem.editNote(noteId, title, content, category)) {
        initializeNotesSystem();
        closePopup(document.querySelector('.popup'));
    }
}

function deleteNote(noteId) {
    if (confirm('–£–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–∞–º–µ—Ç–∫—É?')) {
        if (notesSystem.deleteNote(noteId)) {
            initializeNotesSystem();
        }
    }
}

function toggleNoteExpand(noteId) {
    if (notesSystem.toggleNoteExpand(noteId)) {
        initializeNotesSystem();
    }
}

function showTagManager(noteId) {
    const note = notesSystem.notes.find(n => n.id === noteId);
    if (!note) return;

    const allTags = notesSystem.getAllTags();
    const currentTags = note.tags;

    showPopup(
        'üè∑Ô∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–≥–∞–º–∏',
        `
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–¢–µ–∫—É—â–∏–µ —Ç–µ–≥–∏:</label>
                <div id="currentTags" style="min-height: 40px; padding: 10px; background: #2c1810; 
                     border-radius: 4px; border: 1px solid #5a3928;">
                    ${currentTags.length > 0 ? 
                        currentTags.map(tag => `
                            <span style="display: inline-block; background: #8b4513; color: #e0d0c0; 
                                   padding: 2px 8px; margin: 2px; border-radius: 10px; font-size: 0.8em;">
                                ${tag}
                                <button onclick="removeTagFromNote('${noteId}', '${tag}')" 
                                        style="background: none; border: none; color: #e74c3c; cursor: pointer; margin-left: 5px;">√ó</button>
                            </span>
                        `).join('') : 
                        '<span style="color: #8b7d6b;">–¢–µ–≥–æ–≤ –Ω–µ—Ç</span>'
                    }
                </div>
            </div>
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–î–æ–±–∞–≤–∏—Ç—å —Ç–µ–≥:</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="newTagInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–≥" 
                           style="flex: 1; padding: 10px; border: 2px solid #8b4513; border-radius: 4px; 
                           background: #1a0f0b; color: #e0d0c0;">
                    <button class="btn btn-plus" onclick="addTagToNote('${noteId}')">–î–æ–±–∞–≤–∏—Ç—å</button>
                </div>
            </div>
            ${allTags.length > 0 ? `
                <div>
                    <label style="display: block; margin-bottom: 5px; color: #d4af37;">–°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ç–µ–≥–∏:</label>
                    <div style="max-height: 100px; overflow-y: auto; padding: 10px; background: #2c1810; 
                         border-radius: 4px; border: 1px solid #5a3928;">
                        ${allTags.filter(tag => !currentTags.includes(tag)).map(tag => `
                            <span onclick="addExistingTagToNote('${noteId}', '${tag}')" 
                                  style="display: inline-block; background: #5a3928; color: #b8a28a; 
                                         padding: 2px 8px; margin: 2px; border-radius: 10px; font-size: 0.8em; 
                                         cursor: pointer; transition: all 0.2s;">
                                ${tag}
                            </span>
                        `).join('')}
                    </div>
                </div>
            ` : ''}
        `,
        [
            '<button class="btn btn-roll" onclick="closePopup(this.closest(\'.popup\'))">–ì–æ—Ç–æ–≤–æ</button>'
        ]
    );
}

function addTagToNote(noteId) {
    const tagInput = document.getElementById('newTagInput');
    const tag = tagInput.value.trim();
    
    if (!tag) {
        alert('–í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥!');
        return;
    }
    
    if (notesSystem.addTagToNote(noteId, tag)) {
        tagInput.value = '';
        showTagManager(noteId); // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ø–∞–ø
        initializeNotesSystem(); // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
    }
}

function addExistingTagToNote(noteId, tag) {
    if (notesSystem.addTagToNote(noteId, tag)) {
        showTagManager(noteId);
        initializeNotesSystem();
    }
}

function removeTagFromNote(noteId, tag) {
    if (notesSystem.removeTagFromNote(noteId, tag)) {
        showTagManager(noteId);
        initializeNotesSystem();
    }
}

// ========== –§–ò–õ–¨–¢–†–ê–¶–ò–Ø –ò –°–û–†–¢–ò–†–û–í–ö–ê ==========

function filterNotes(searchTerm) {
    let filteredNotes;
    
    if (searchTerm.trim() === '') {
        filteredNotes = notesSystem.notes;
    } else {
        filteredNotes = notesSystem.searchNotes(searchTerm);
    }
    
    document.getElementById('notesContainer').innerHTML = renderNotes(filteredNotes);
}

function filterNotesByCategory(category) {
    let filteredNotes;
    
    if (category === 'all') {
        filteredNotes = notesSystem.notes;
    } else {
        filteredNotes = notesSystem.getNotesByCategory(category);
    }
    
    document.getElementById('notesContainer').innerHTML = renderNotes(filteredNotes);
    
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    document.querySelectorAll('.category-item').forEach(item => {
        const btn = item.querySelector('button');
        if (item.getAttribute('data-category') === category) {
            btn.style.background = '#8b4513';
            btn.style.fontWeight = 'bold';
        } else {
            btn.style.background = '';
            btn.style.fontWeight = '';
        }
    });
}

function filterNotesByTag(tag) {
    const filteredNotes = notesSystem.notes.filter(note => 
        note.tags.includes(tag)
    );
    
    document.getElementById('notesContainer').innerHTML = renderNotes(filteredNotes);
    document.getElementById('notesSearch').value = tag;
}

function sortNotes(sortBy) {
    let sortedNotes = [...notesSystem.notes];
    
    switch (sortBy) {
        case 'newest':
            sortedNotes.sort((a, b) => new Date(b.created) - new Date(a.created));
            break;
        case 'oldest':
            sortedNotes.sort((a, b) => new Date(a.created) - new Date(b.created));
            break;
        case 'title':
            sortedNotes.sort((a, b) => a.title.localeCompare(b.title));
            break;
        case 'updated':
            sortedNotes.sort((a, b) => new Date(b.updated) - new Date(a.updated));
            break;
    }
    
    document.getElementById('notesContainer').innerHTML = renderNotes(sortedNotes);
}

// ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–¢–ï–ì–û–†–ò–Ø–ú–ò ==========

function showCategoryManager() {
    showPopup(
        'üìÇ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏',
        `
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–°—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:</label>
                <div id="categoriesManagerList" style="max-height: 200px; overflow-y: auto; padding: 10px; 
                     background: #2c1810; border-radius: 4px; border: 1px solid #5a3928;">
                    ${notesSystem.categories.map(category => `
                        <div style="display: flex; justify-content: space-between; align-items: center; 
                             padding: 5px 0; border-bottom: 1px solid #3d2418;">
                            <span>${category}</span>
                            <button class="btn btn-small" onclick="deleteCategory('${category}')" 
                                    style="background: #c44536; padding: 2px 6px; font-size: 10px;"
                                    ${notesSystem.getNotesByCategory(category).length > 0 ? 'disabled' : ''}>
                                –£–¥–∞–ª–∏—Ç—å
                            </button>
                        </div>
                    `).join('')}
                </div>
            </div>
            <div>
                <label style="display: block; margin-bottom: 5px; color: #d4af37;">–î–æ–±–∞–≤–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é:</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="newCategoryInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏" 
                           style="flex: 1; padding: 10px; border: 2px solid #8b4513; border-radius: 4px; 
                           background: #1a0f0b; color: #e0d0c0;">
                    <button class="btn btn-plus" onclick="addNewCategory()">–î–æ–±–∞–≤–∏—Ç—å</button>
                </div>
            </div>
        `,
        [
            '<button class="btn btn-roll" onclick="closePopup(this.closest(\'.popup\'))">–ì–æ—Ç–æ–≤–æ</button>'
        ]
    );
}

function addNewCategory() {
    const categoryInput = document.getElementById('newCategoryInput');
    const category = categoryInput.value.trim();
    
    if (!category) {
        alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏!');
        return;
    }
    
    if (notesSystem.categories.includes(category)) {
        alert('–¢–∞–∫–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!');
        return;
    }
    
    notesSystem.categories.push(category);
    notesSystem.saveNotes();
    categoryInput.value = '';
    showCategoryManager();
    initializeNotesSystem();
}

function deleteCategory(category) {
    if (notesSystem.getNotesByCategory(category).length > 0) {
        alert('–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é, –≤ –∫–æ—Ç–æ—Ä–æ–π –µ—Å—Ç—å –∑–∞–º–µ—Ç–∫–∏!');
        return;
    }
    
    if (confirm(`–£–¥–∞–ª–∏—Ç—å –∫–∞—Ç–µ–≥–æ—Ä–∏—é "${category}"?`)) {
        const categoryIndex = notesSystem.categories.indexOf(category);
        if (categoryIndex !== -1) {
            notesSystem.categories.splice(categoryIndex, 1);
            notesSystem.saveNotes();
            showCategoryManager();
            initializeNotesSystem();
        }
    }
}

// ========== –≠–ö–°–ü–û–†–¢ –ò –ò–ú–ü–û–†–¢ ==========

function exportNotes() {
    const dataStr = notesSystem.exportNotes();
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `dnd_notes_${new Date().toISOString().split('T')[0]}.json`;
    link.click();
    
    alert(`‚úÖ –ó–∞–º–µ—Ç–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã! –í—Å–µ–≥–æ: ${notesSystem.notes.length} –∑–∞–º–µ—Ç–æ–∫`);
}

function importNotes() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importedCount = notesSystem.importNotes(e.target.result);
                if (importedCount > 0) {
                    initializeNotesSystem();
                    alert(`‚úÖ –ó–∞–º–µ—Ç–∫–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã! –ó–∞–≥—Ä—É–∂–µ–Ω–æ: ${importedCount} –∑–∞–º–µ—Ç–æ–∫`);
                } else {
                    alert('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–º–µ—Ç–∫–∏!');
                }
            } catch (error) {
                alert('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞!');
            }
        };
        reader.readAsText(file);
    };
    
    input.click();
}

function showClearAllPopup() {
    if (notesSystem.notes.length === 0) {
        alert('–ù–µ—Ç –∑–∞–º–µ—Ç–æ–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è!');
        return;
    }

    if (confirm(`‚ùå –í–´ –£–í–ï–†–ï–ù–´?\n\n–≠—Ç–æ —É–¥–∞–ª–∏—Ç –í–°–ï –∑–∞–º–µ—Ç–∫–∏ (${notesSystem.notes.length} —à—Ç.)!\n–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å!`)) {
        notesSystem.clearAllNotes();
        initializeNotesSystem();
        alert('‚úÖ –í—Å–µ –∑–∞–º–µ—Ç–∫–∏ —É–¥–∞–ª–µ–Ω—ã!');
    }
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ==========

console.log('‚úÖ notes.js –∑–∞–≥—Ä—É–∂–µ–Ω! –°–∏—Å—Ç–µ–º–∞ –∑–∞–º–µ—Ç–æ–∫ –≥–æ—Ç–æ–≤–∞.');
